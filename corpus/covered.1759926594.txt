/code/contracts/hub/ControllerHub.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.24;
   3 |     | 
   4 |     | import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
   5 |     | import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
   6 |     | import {AccessControlUpgradeable} from "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
   7 |     | import {PausableUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol";
   8 |     | import {ReentrancyGuardUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol";
   9 |     | import {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";
  10 |     | import {Math} from "@openzeppelin/contracts/utils/math/Math.sol";
  11 |     | import {IPriceOracleRouter} from "../interfaces/IPriceOracleRouter.sol";
  12 |     | import {ISpokeYieldVault} from "../interfaces/ISpokeYieldVault.sol";
  13 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  14 |     | 
  15 |     | /// @title ControllerHub
  16 |     | /// @notice Lending/borrowing controller hub with RAY fixed-point math and kinked IRM.
  17 | *   | contract ControllerHub is
  18 |     |     Initializable,
  19 |     |     UUPSUpgradeable,
  20 |     |     AccessControlUpgradeable,
  21 |     |     PausableUpgradeable,
  22 |     |     ReentrancyGuardUpgradeable
  23 |     | {
  24 |     |     using SafeCast for uint256;
  25 |     | 
  26 |     |     // Roles
  27 | *   |     bytes32 public constant GOVERNOR_ROLE = keccak256("GOVERNOR_ROLE");
  28 |     | 
  29 |     |     // Constants
  30 |     |     uint256 public constant RAY = 1e27;
  31 |     |     uint256 public constant WAD = 1e18;
  32 | *   |     uint256 public constant BPS = 10_000;
  33 |     | 
  34 |     |     struct MarketParams {
  35 |     |         uint16 ltvBps;
  36 |     |         uint16 liqThresholdBps;
  37 |     |         uint16 reserveFactorBps;
  38 |     |         uint128 borrowCap;
  39 |     |         uint16 kinkBps; // utilization kink in bps
  40 |     |         uint128 slope1Ray; // per-second rate in ray below kink
  41 |     |         uint128 slope2Ray; // per-second rate in ray above kink
  42 |     |         uint128 baseRateRay; // per-second base rate
  43 |     |         address lst; // collateral LST token associated for this market
  44 |     |         address vault; // spoke vault to seize shares on
  45 |     |     }
  46 |     | 
  47 |     |     struct MarketState {
  48 |     |         uint256 supplyIndexRay;
  49 |     |         uint256 debtIndexRay;
  50 |     |         uint40 lastAccrual;
  51 |     |         uint216 totalBorrows; // in asset units
  52 |     |         uint216 totalReserves; // in asset units
  53 |     |     }
  54 |     | 
  55 |     |     // Per market and user storage
  56 |     |     mapping(address => MarketParams) public marketParams; // asset => params
  57 |     |     mapping(address => MarketState) public marketState; // asset => state
  58 |     |     mapping(address => mapping(address => bool)) public isEntered; // user => lst => entered as collateral
  59 |     |     mapping(address => mapping(address => uint256)) public debtPrincipal; // user => asset => principal amount
  60 |     |     mapping(address => mapping(address => uint256)) public debtIndexSnapshot; // user => asset => debt index at last update
  61 |     |     // Market enumeration for production multi-market accounting
  62 |     |     address[] private _markets;
  63 |     |     mapping(address => bool) public isMarket;
  64 |     | 
  65 |     |     // External dependencies
  66 |     |     IPriceOracleRouter public oracle;
  67 |     | 
  68 |     |     // Events
  69 |     |     event MarketListed(
  70 |     |         address indexed asset,
  71 |     |         uint16 ltvBps,
  72 |     |         uint16 liqThresholdBps,
  73 |     |         uint16 reserveFactorBps,
  74 |     |         uint16 kinkBps,
  75 |     |         uint64 baseRateRayPerSec,
  76 |     |         uint64 slope1RayPerSec,
  77 |     |         uint64 slope2RayPerSec,
  78 |     |         uint256 borrowCap
  79 |     |     );
  80 |     |     event MarketParamsUpdated(
  81 |     |         address indexed asset,
  82 |     |         uint16 ltvBps,
  83 |     |         uint16 liqThresholdBps,
  84 |     |         uint16 reserveFactorBps,
  85 |     |         uint16 kinkBps,
  86 |     |         uint64 baseRateRayPerSec,
  87 |     |         uint64 slope1RayPerSec,
  88 |     |         uint64 slope2RayPerSec,
  89 |     |         uint256 borrowCap
  90 |     |     );
  91 |     |     event Accrued(
  92 |     |         address indexed asset,
  93 |     |         uint256 supplyIndexRay,
  94 |     |         uint256 debtIndexRay,
  95 |     |         uint256 totalBorrows,
  96 |     |         uint256 totalReserves,
  97 |     |         uint256 timestamp
  98 |     |     );
  99 |     |     event EnterMarket(address indexed user, address indexed lst);
 100 |     |     event ExitMarket(address indexed user, address indexed lst);
 101 |     |     // KPI/events for off-chain observability and tests
 102 |     |     event BorrowRequested(
 103 |     |         address indexed user, address indexed asset, uint256 amount, uint256 dstChainId, bytes32 actionId, uint256 ts
 104 |     |     );
 105 |     |     event BorrowDecision(
 106 |     |         address indexed user, address indexed asset, uint256 amount, uint8 routesUsed, bytes32 actionId, uint256 ts
 107 |     |     );
 108 |     |     event IRMRateUpdated(address indexed asset, uint256 newBorrowRateRayPerSec, uint256 utilizationRay, uint256 ts);
 109 |     |     event BorrowPaused(address indexed asset, uint256 ts);
 110 |     |     event Borrow(
 111 |     |         address indexed user,
 112 |     |         address indexed asset,
 113 |     |         uint256 amount,
 114 |     |         uint256 debtIndexRay,
 115 |     |         uint256 hfBps,
 116 |     |         uint256 dstChainId,
 117 |     |         bytes32 actionId
 118 |     |     );
 119 |     |     event Repay(
 120 |     |         address indexed user,
 121 |     |         address indexed asset,
 122 |     |         uint256 amount,
 123 |     |         uint256 debtIndexRay,
 124 |     |         uint256 srcChainId,
 125 |     |         bytes32 actionId
 126 |     |     );
 127 |     |     event Liquidate(
 128 |     |         address indexed liquidator,
 129 |     |         address indexed user,
 130 |     |         address indexed repayAsset,
 131 |     |         uint256 repayAmount,
 132 |     |         address seizeLst,
 133 |     |         uint256 seizeShares,
 134 |     |         uint256 discountBps,
 135 |     |         bytes32 actionId
 136 |     |     );
 137 |     |     event BorrowCapSet(address indexed asset, uint256 cap);
 138 |     |     event PauseSet(bool deposits, bool borrows, bool bridge, bool liquidations);
 139 |     |     event GovernorProposed(address indexed currentGovernor, address indexed pendingGovernor);
 140 |     |     event GovernorAccepted(address indexed previousGovernor, address indexed newGovernor);
 141 |     | 
 142 |     |     // Errors
 143 |     |     error MarketNotListed();
 144 |     |     error InvalidParams();
 145 |     |     error ExceedsBorrowCap();
 146 |     |     error InsufficientCollateral();
 147 |     |     error NotEnteredMarket();
 148 |     | 
 149 |     |     struct Liq {
 150 |     |         uint256 priceLst;
 151 |     |         uint256 priceAsset;
 152 |     |         uint256 ar;
 153 |     |         uint256 shares;
 154 |     |     }
 155 |     |     // Policy constants
 156 |     | 
 157 | *   |     uint256 public constant CLOSE_FACTOR_BPS = 5000; // 50%
 158 |     |     uint256 public constant LIQ_BONUS_BPS = 1000; // 10%
 159 |     | 
 160 |     |     // Pause flags
 161 |     |     bool public borrowsPaused;
 162 |     |     bool public liquidationsPaused;
 163 |     |     address public governor;
 164 |     |     address public pendingGovernor;
 165 |     | 
 166 |     |     /// @notice Set borrow or liquidation pause flags.
 167 |     |     function setPause(bool _borrows, bool _liquidations) external onlyRole(GOVERNOR_ROLE) {
 168 | *   |         borrowsPaused = _borrows;
 169 |     |         liquidationsPaused = _liquidations;
 170 | *   |         emit PauseSet(false, _borrows, false, _liquidations);
 171 | *   |         if (_borrows) {
 172 |     |             // Global pause (asset-less); emit with zero address for compatibility
 173 | *   |             emit BorrowPaused(address(0), block.timestamp);
 174 |     |         }
 175 |     |     }
 176 |     | 
 177 |     |     // ---------------- internal helpers ----------------
 178 | *   |     function _price1e18(address asset) internal view returns (uint256 price1e18) {
 179 | *   |         (uint256 price, uint8 dec,) = oracle.getPrice(asset);
 180 | *   |         if (dec == 18) return price;
 181 | *   |         if (dec < 18) return price * (10 ** (18 - dec));
 182 |     |         return price / (10 ** (dec - 18));
 183 |     |     }
 184 |     | 
 185 | *   |     function _actionId(string memory msgType, address user, address asset, uint256 amount, uint256 nonce)
 186 |     |         internal
 187 |     |         view
 188 |     |         returns (bytes32)
 189 |     |     {
 190 | *   |         return keccak256(
 191 | *   |             abi.encode(
 192 |     |                 msgType,
 193 | *   |                 uint256(1),
 194 | *   |                 block.chainid,
 195 | *   |                 address(this),
 196 |     |                 block.chainid,
 197 |     |                 address(this),
 198 |     |                 user,
 199 |     |                 asset,
 200 |     |                 amount,
 201 |     |                 nonce
 202 |     |             )
 203 |     |         );
 204 |     |     }
 205 |     | 
 206 |     |     /// @notice Decrease user debt by a repay amount in asset units; rounds in principal space and converts back to assets.
 207 |     |     function _decreaseDebt(address user, address asset, uint256 idxRay, uint256 repayAmountAsset)
 208 |     |         internal
 209 |     |         returns (uint256 actualRepaidAsset)
 210 |     |     {
 211 |     |         MarketState storage s = marketState[asset];
 212 |     |         uint256 rp = (repayAmountAsset * RAY) / idxRay; // repay principal units
 213 |     |         uint256 princ = debtPrincipal[user][asset];
 214 |     |         if (rp > princ) rp = princ;
 215 |     |         debtPrincipal[user][asset] = princ - rp;
 216 |     |         debtIndexSnapshot[user][asset] = idxRay;
 217 |     |         // convert capped rp back to asset units as actual repaid
 218 |     |         actualRepaidAsset = Math.mulDiv(rp, idxRay, RAY);
 219 |     |         uint256 tb = s.totalBorrows;
 220 |     |         if (actualRepaidAsset > tb) actualRepaidAsset = tb;
 221 | *   |         s.totalBorrows = SafeCast.toUint216(tb - actualRepaidAsset);
 222 |     |     }
 223 |     | 
 224 |     |     function _increaseDebt(address user, address asset, uint256 amount) internal returns (uint256 newPrincipal) {
 225 |     |         MarketState storage s = marketState[asset];
 226 | *   |         uint256 idx = s.debtIndexRay;
 227 | *   |         uint256 addPrincipal = (amount * RAY) / idx;
 228 | *   |         newPrincipal = debtPrincipal[user][asset] + addPrincipal;
 229 |     |         debtPrincipal[user][asset] = newPrincipal;
 230 |     |         debtIndexSnapshot[user][asset] = idx;
 231 |     |     }
 232 |     | 
 233 | *   |     function _isBorrowAllowed(address user, address asset, uint256 amount) internal view returns (bool) {
 234 | *   |         MarketParams storage p = marketParams[asset];
 235 | *   |         if (!isEntered[user][p.lst]) return false;
 236 | *   |         uint256 lstBal = IERC20(p.lst).balanceOf(user);
 237 | *   |         uint256 priceLst1e18 = _price1e18(p.lst);
 238 | *   |         uint256 priceAsset1e18 = _price1e18(asset);
 239 | *   |         uint256 collValueWad = Math.mulDiv(lstBal, priceLst1e18, 1e18);
 240 | *   |         uint256 curDebt = currentDebt(user, asset);
 241 | *   |         uint256 curDebtValueWad = Math.mulDiv(curDebt, priceAsset1e18, 1e18);
 242 | *   |         uint256 addDebtValueWad = Math.mulDiv(amount, priceAsset1e18, 1e18);
 243 | *   |         uint256 maxDebtWad = (collValueWad * uint256(p.ltvBps)) / BPS;
 244 | *   |         return curDebtValueWad + addDebtValueWad <= maxDebtWad;
 245 |     |     }
 246 |     | 
 247 |     |     function initialize(address initialGovernor, address oracle_) external initializer {
 248 |     |         __UUPSUpgradeable_init();
 249 |     |         __AccessControl_init();
 250 |     |         __Pausable_init();
 251 |     |         __ReentrancyGuard_init();
 252 | *   |         _grantRole(DEFAULT_ADMIN_ROLE, initialGovernor);
 253 | *   |         _grantRole(GOVERNOR_ROLE, initialGovernor);
 254 | *   |         oracle = IPriceOracleRouter(oracle_);
 255 | *   |         governor = initialGovernor;
 256 |     |     }
 257 |     | 
 258 |     |     function _authorizeUpgrade(address) internal override onlyRole(GOVERNOR_ROLE) {}
 259 |     | 
 260 |     |     // --- Two-step governor ---
 261 |     |     function proposeGovernor(address newGov) external onlyRole(GOVERNOR_ROLE) {
 262 |     |         if (newGov == address(0)) revert InvalidParams();
 263 |     |         pendingGovernor = newGov;
 264 |     |         emit GovernorProposed(governor, newGov);
 265 |     |     }
 266 |     | 
 267 |     |     function acceptGovernor() external {
 268 |     |         require(msg.sender == pendingGovernor, "NOT_PENDING");
 269 |     |         address prev = governor;
 270 |     |         _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
 271 |     |         _grantRole(GOVERNOR_ROLE, msg.sender);
 272 |     |         _revokeRole(GOVERNOR_ROLE, prev);
 273 |     |         _revokeRole(DEFAULT_ADMIN_ROLE, prev);
 274 |     |         governor = msg.sender;
 275 |     |         pendingGovernor = address(0);
 276 |     |         emit GovernorAccepted(prev, msg.sender);
 277 |     |     }
 278 |     | 
 279 |     |     // Admin: list market
 280 |     |     function listMarket(address asset, bytes calldata params) external onlyRole(GOVERNOR_ROLE) {
 281 | *   |         MarketParams memory p = abi.decode(params, (MarketParams));
 282 |     |         // Policy bounds: LTV < LT; kink within [1000, 9500]; close factor/bonus constants already bounded; slope/base rays must be reasonable.
 283 | *   |         if (asset == address(0) || p.lst == address(0)) revert InvalidParams();
 284 | *   |         if (p.liqThresholdBps <= p.ltvBps) revert InvalidParams();
 285 | *   |         if (p.kinkBps < 1000 || p.kinkBps > 9500) revert InvalidParams();
 286 |     |         if (CLOSE_FACTOR_BPS > 5000) revert InvalidParams();
 287 |     |         if (LIQ_BONUS_BPS > 1000) revert InvalidParams();
 288 | *   |         if (p.kinkBps < 1000 || p.kinkBps > 9500) revert InvalidParams();
 289 |     |         // Reserve factor ≤ 50%
 290 | *   |         if (p.reserveFactorBps > 5000) revert InvalidParams();
 291 |     |         // Nonzero indices params
 292 | *   |         if (p.slope2Ray < p.slope1Ray) revert InvalidParams();
 293 |     |         marketParams[asset] = p;
 294 | *   |         if (!isMarket[asset]) {
 295 |     |             isMarket[asset] = true;
 296 | *   |             _markets.push(asset);
 297 |     |         }
 298 | *   |         marketState[asset] = MarketState({
 299 |     |             supplyIndexRay: RAY,
 300 |     |             debtIndexRay: RAY,
 301 | *   |             lastAccrual: uint40(block.timestamp),
 302 |     |             totalBorrows: 0,
 303 |     |             totalReserves: 0
 304 |     |         });
 305 | *   |         emit MarketListed(
 306 |     |             asset,
 307 |     |             p.ltvBps,
 308 |     |             p.liqThresholdBps,
 309 |     |             p.reserveFactorBps,
 310 |     |             p.kinkBps,
 311 |     |             uint64(p.baseRateRay),
 312 |     |             uint64(p.slope1Ray),
 313 |     |             uint64(p.slope2Ray),
 314 |     |             p.borrowCap
 315 |     |         );
 316 |     |     }
 317 |     | 
 318 |     |     // Admin: update params
 319 |     |     function setParams(address asset, bytes calldata params) external onlyRole(GOVERNOR_ROLE) {
 320 |     |         MarketParams memory p = abi.decode(params, (MarketParams));
 321 |     |         if (p.lst == address(0)) revert InvalidParams();
 322 |     |         if (p.liqThresholdBps <= p.ltvBps) revert InvalidParams();
 323 |     |         if (p.kinkBps < 1000 || p.kinkBps > 9500) revert InvalidParams();
 324 |     |         if (CLOSE_FACTOR_BPS > 5000) revert InvalidParams();
 325 |     |         if (LIQ_BONUS_BPS > 1000) revert InvalidParams();
 326 |     |         if (p.kinkBps < 1000 || p.kinkBps > 9500) revert InvalidParams();
 327 |     |         if (p.reserveFactorBps > 5000) revert InvalidParams();
 328 |     |         if (p.slope2Ray < p.slope1Ray) revert InvalidParams();
 329 |     |         marketParams[asset] = p;
 330 |     |         emit MarketParamsUpdated(
 331 |     |             asset,
 332 |     |             p.ltvBps,
 333 |     |             p.liqThresholdBps,
 334 |     |             p.reserveFactorBps,
 335 |     |             p.kinkBps,
 336 |     |             uint64(p.baseRateRay),
 337 |     |             uint64(p.slope1Ray),
 338 |     |             uint64(p.slope2Ray),
 339 |     |             p.borrowCap
 340 |     |         );
 341 |     |     }
 342 |     | 
 343 |     |     // Collateral: enable LST as collateral
 344 |     |     function enterMarket(address lst) external {
 345 | *   |         isEntered[msg.sender][lst] = true;
 346 | *   |         emit EnterMarket(msg.sender, lst);
 347 |     |     }
 348 |     | 
 349 |     |     function exitMarket(address lst) external {
 350 |     |         // Block exit when unhealthy
 351 |     |         uint256 hf = healthFactor(msg.sender);
 352 |     |         require(hf >= 1e18, "UNHEALTHY");
 353 |     |         isEntered[msg.sender][lst] = false;
 354 |     |         emit ExitMarket(msg.sender, lst);
 355 |     |     }
 356 |     | 
 357 |     |     // Accrual for a specific market
 358 | *   |     function accrue(address asset) public {
 359 | *   |         MarketState storage s = marketState[asset];
 360 |     |         MarketParams storage p = marketParams[asset];
 361 | *   |         if (s.lastAccrual == 0) revert MarketNotListed();
 362 |     |         uint256 last = s.lastAccrual;
 363 | *   |         if (block.timestamp == last) return;
 364 | *   |         uint256 dt = block.timestamp - last;
 365 |     | 
 366 |     |         // Utilization estimation: U = totalBorrows / (totalBorrows + 1) to avoid div by zero (no on-chain cash accounting here)
 367 |     |         uint256 borrows = uint256(s.totalBorrows);
 368 | *   |         uint256 utilizationRay = borrows == 0 ? 0 : (borrows * RAY) / (borrows + 1);
 369 |     | 
 370 |     |         // Borrow rate per second (ray)
 371 |     |         uint256 rateRay;
 372 | *   |         if (utilizationRay <= (uint256(p.kinkBps) * RAY) / BPS) {
 373 |     |             rateRay =
 374 | *   |                 uint256(p.baseRateRay) + (uint256(p.slope1Ray) * utilizationRay) / ((uint256(p.kinkBps) * RAY) / BPS);
 375 |     |         } else {
 376 | *   |             uint256 over = utilizationRay - ((uint256(p.kinkBps) * RAY) / BPS);
 377 |     |             uint256 denom = RAY - ((uint256(p.kinkBps) * RAY) / BPS);
 378 | *   |             rateRay = uint256(p.baseRateRay) + uint256(p.slope1Ray) + (uint256(p.slope2Ray) * over) / denom;
 379 |     |         }
 380 |     | 
 381 |     |         // Linearized index growth: idx = idx * (1 + rate*dt)
 382 | *   |         uint256 deltaRay = rateRay * dt;
 383 | *   |         s.debtIndexRay = (s.debtIndexRay * (RAY + deltaRay)) / RAY;
 384 |     |         // Supply index approximate with utilization and reserve factor
 385 |     |         uint256 rf = uint256(p.reserveFactorBps);
 386 | *   |         uint256 supplyRateRay = (rateRay * utilizationRay * (BPS - rf)) / (RAY * BPS);
 387 | *   |         uint256 supplyDeltaRay = supplyRateRay * dt;
 388 | *   |         s.supplyIndexRay = (s.supplyIndexRay * (RAY + supplyDeltaRay)) / RAY;
 389 |     | 
 390 |     |         s.lastAccrual = uint40(block.timestamp);
 391 | *   |         emit IRMRateUpdated(asset, rateRay, utilizationRay, block.timestamp);
 392 | *   |         emit Accrued(asset, s.supplyIndexRay, s.debtIndexRay, s.totalBorrows, s.totalReserves, block.timestamp);
 393 |     |     }
 394 |     | 
 395 |     |     // Compute current user debt in asset units
 396 | *   |     function currentDebt(address user, address asset) public view returns (uint256) {
 397 | *   |         MarketState storage s = marketState[asset];
 398 | *   |         if (s.lastAccrual == 0) return 0;
 399 | *   |         uint256 principal = debtPrincipal[user][asset];
 400 | *   |         if (principal == 0) return 0;
 401 | *   |         uint256 snapshot = debtIndexSnapshot[user][asset];
 402 | *   |         if (snapshot == 0) snapshot = RAY;
 403 | *   |         return (principal * s.debtIndexRay) / snapshot;
 404 |     |     }
 405 |     | 
 406 |     |     /// @notice Compute account health factor across all listed markets.
 407 |     |     /// HF = (Σ_i price(lst_i) * balance(lst_i) * LT_i / 1e4) / (Σ_j price(asset_j) * debt_j)
 408 |     |     /// Returns 1e18 when no debt.
 409 | *   |     function healthFactor(address user) public view returns (uint256 hfWad) {
 410 | *   |         (uint256 coll, uint256 debt,) = accountLiquidity(user);
 411 | *   |         if (debt == 0) return 1e18;
 412 |     |         return Math.mulDiv(coll, 1e18, debt);
 413 |     |     }
 414 |     | 
 415 |     |     /// @notice Returns (collateralValueWad, debtValueWad, shortfallWad) across all markets.
 416 | *   |     function accountLiquidity(address user)
 417 |     |         public
 418 |     |         view
 419 | *   |         returns (uint256 collateralValueWad, uint256 debtValueWad, uint256 shortfallWad)
 420 |     |     {
 421 | *   |         uint256 mlen = _markets.length;
 422 | *   |         for (uint256 i = 0; i < mlen; i++) {
 423 | *   |             address asset = _markets[i];
 424 |     |             MarketParams storage p = marketParams[asset];
 425 | *   |             if (p.lst != address(0) && isEntered[user][p.lst]) {
 426 | *   |                 uint256 lstBal = IERC20(p.lst).balanceOf(user);
 427 | *   |                 uint256 priceLst1e18 = _price1e18(p.lst);
 428 | *   |                 uint256 collWad = Math.mulDiv(lstBal, priceLst1e18, 1e18);
 429 | *   |                 collateralValueWad += (collWad * uint256(p.liqThresholdBps)) / BPS;
 430 |     |             }
 431 |     |         }
 432 | *   |         for (uint256 i = 0; i < mlen; i++) {
 433 | *   |             address asset = _markets[i];
 434 | *   |             uint256 d = currentDebt(user, asset);
 435 | *   |             if (d != 0) {
 436 | *   |                 uint256 priceAsset1e18 = _price1e18(asset);
 437 | *   |                 debtValueWad += Math.mulDiv(d, priceAsset1e18, 1e18);
 438 |     |             }
 439 |     |         }
 440 | *   |         if (debtValueWad > collateralValueWad) shortfallWad = debtValueWad - collateralValueWad;
 441 |     |         else shortfallWad = 0;
 442 |     |     }
 443 |     | 
 444 |     |     // Borrow increases user's debt and emits instruction to payout cross-chain
 445 |     |     function borrow(address asset, uint256 amount, uint256 dstChainId) external nonReentrant whenNotPaused {
 446 | *   |         if (borrowsPaused) revert InsufficientCollateral(); // reuse error; alternatively define Paused
 447 | *   |         accrue(asset);
 448 |     |         MarketParams storage p = marketParams[asset];
 449 | *   |         if (marketState[asset].lastAccrual == 0) revert MarketNotListed();
 450 |     | 
 451 |     |         // Collateral check using LTV and oracle prices
 452 | *   |         if (!_isBorrowAllowed(msg.sender, asset, amount)) revert InsufficientCollateral();
 453 |     | 
 454 |     |         // Emit borrow request intent prior to routing/decision
 455 | *   |         bytes32 reqAid = _actionId("BorrowRequested", msg.sender, asset, amount, block.number);
 456 | *   |         emit BorrowRequested(msg.sender, asset, amount, dstChainId, reqAid, block.timestamp);
 457 |     | 
 458 |     |         // Cap enforcement and state updates
 459 |     |         MarketState storage s = marketState[asset];
 460 | *   |         uint256 newTotalBorrows = uint256(s.totalBorrows) + amount;
 461 | *   |         if (newTotalBorrows > uint256(p.borrowCap)) revert ExceedsBorrowCap();
 462 | *   |         s.totalBorrows = SafeCast.toUint216(newTotalBorrows);
 463 |     | 
 464 |     |         // Global HF check: ensure user remains healthy (>=1) after proposed borrow
 465 |     |         // Approximate by checking current HF; exact projection requires simulating added debt in value terms.
 466 |     |         // We reuse per-asset LTV gate for precise per-market constraint and rely on HF for global risk.
 467 | *   |         require(healthFactor(msg.sender) >= 1e18, "HF_LT_1");
 468 |     |         _increaseDebt(msg.sender, asset, amount);
 469 |     |         _emitBorrow(msg.sender, asset, amount, dstChainId);
 470 |     |         // Emit a decision with number of routes used (single route in current implementation)
 471 | *   |         bytes32 decAid = _actionId("BorrowDecision", msg.sender, asset, amount, block.number);
 472 | *   |         emit BorrowDecision(msg.sender, asset, amount, 1, decAid, block.timestamp);
 473 |     |         // Cross-chain payout is performed by relayers calling spoke vaults.
 474 |     |     }
 475 |     | 
 476 |     |     function _emitBorrow(address user, address asset, uint256 amount, uint256 dstChainId) internal {
 477 |     |         MarketParams storage p = marketParams[asset];
 478 | *   |         uint256 idx = marketState[asset].debtIndexRay;
 479 | *   |         uint256 priceLst1e18 = _price1e18(p.lst);
 480 | *   |         uint256 priceAsset1e18 = _price1e18(asset);
 481 | *   |         uint256 lstBal = IERC20(p.lst).balanceOf(user);
 482 | *   |         uint256 collValueWad = Math.mulDiv(lstBal, priceLst1e18, 1e18);
 483 | *   |         uint256 debtValueWad = Math.mulDiv(currentDebt(user, asset), priceAsset1e18, 1e18);
 484 | *   |         uint256 hfBps = debtValueWad == 0 ? type(uint256).max : (collValueWad * BPS) / debtValueWad;
 485 | *   |         bytes32 aid = _actionId("Borrow", user, asset, amount, block.number);
 486 | *   |         emit Borrow(user, asset, amount, idx, hfBps, dstChainId, aid);
 487 |     |     }
 488 |     | 
 489 |     |     /// @notice Returns the list of all listed borrow markets (asset addresses).
 490 |     |     function allMarkets() external view returns (address[] memory) {
 491 |     |         return _markets;
 492 |     |     }
 493 |     | 
 494 |     |     // Repay reduces principal
 495 | *   |     function repay(address asset, uint256 amount, uint256 srcChainId) external nonReentrant whenNotPaused {
 496 | *   |         accrue(asset);
 497 | *   |         MarketState storage s = marketState[asset];
 498 | *   |         if (s.lastAccrual == 0) revert MarketNotListed();
 499 | *   |         uint256 idx = s.debtIndexRay;
 500 | *   |         uint256 principal = debtPrincipal[msg.sender][asset];
 501 | *   |         if (principal == 0) return;
 502 | *   |         uint256 repayPrincipal = (amount * RAY) / idx;
 503 | *   |         if (repayPrincipal > principal) repayPrincipal = principal;
 504 | *   |         debtPrincipal[msg.sender][asset] = principal - repayPrincipal;
 505 | *   |         debtIndexSnapshot[msg.sender][asset] = idx;
 506 | *   |         uint256 newTotalBorrows = uint256(s.totalBorrows) - Math.min(amount, uint256(s.totalBorrows));
 507 | *   |         s.totalBorrows = SafeCast.toUint216(newTotalBorrows);
 508 |     |         _emitRepay(msg.sender, asset, amount, srcChainId, idx);
 509 |     |     }
 510 |     | 
 511 |     |     function _emitRepay(address user, address asset, uint256 amount, uint256 srcChainId, uint256 idx) internal {
 512 | *   |         emit Repay(user, asset, amount, idx, srcChainId, _actionId("Repay", user, asset, amount, block.number));
 513 |     |     }
 514 |     | 
 515 |     |     // Liquidation: repay on behalf and seize LST shares
 516 |     |     function liquidate(address user, address repayAsset, uint256 repayAmount, address seizeLst, address to)
 517 |     |         external
 518 |     |         nonReentrant
 519 |     |         whenNotPaused
 520 |     |     {
 521 |     |         if (liquidationsPaused) revert NotEnteredMarket();
 522 |     |         accrue(repayAsset);
 523 |     |         (uint256 ar, uint256 shares, address vaultAddr) =
 524 |     |             _quoteAndValidateLiquidation(user, repayAsset, repayAmount, seizeLst);
 525 |     |         _finalizeLiquidation(user, repayAsset, ar, seizeLst, vaultAddr, shares, to);
 526 |     |     }
 527 |     | 
 528 |     |     function _quoteAndValidateLiquidation(address user, address repayAsset, uint256 repayAmount, address seizeLst)
 529 |     |         internal
 530 |     |         view
 531 |     |         returns (uint256 ar, uint256 shares, address vaultAddr)
 532 |     |     {
 533 |     |         MarketParams storage p = marketParams[repayAsset];
 534 |     |         if (p.lst != seizeLst) revert InvalidParams();
 535 |     |         uint256 d = currentDebt(user, repayAsset);
 536 |     |         if (d == 0) revert InsufficientCollateral();
 537 |     |         if (!isEntered[user][seizeLst]) revert NotEnteredMarket();
 538 |     | 
 539 |     |         uint256 priceLst = _price1e18(seizeLst);
 540 |     |         uint256 priceAsset = _price1e18(repayAsset);
 541 | *   |         uint256 collWad = Math.mulDiv(IERC20(seizeLst).balanceOf(user), priceLst, 1e18);
 542 |     |         uint256 debtWad = Math.mulDiv(d, priceAsset, 1e18);
 543 |     |         uint256 liqLimit = (collWad * uint256(p.liqThresholdBps)) / BPS;
 544 |     |         if (debtWad <= liqLimit) revert InsufficientCollateral();
 545 |     | 
 546 |     |         ar = Math.min(repayAmount, (d * CLOSE_FACTOR_BPS) / BPS);
 547 |     |         uint256 repayValueWad = Math.mulDiv(ar, priceAsset, 1e18);
 548 |     |         uint256 seizeValueWad = (repayValueWad * (10_000 + LIQ_BONUS_BPS)) / BPS;
 549 |     |         // Round up to ensure the protocol does not under-seize due to truncation when converting value to shares
 550 |     |         uint256 num = Math.mulDiv(seizeValueWad, 1e18, 1); // keep precision
 551 |     |         shares = Math.ceilDiv(num, priceLst);
 552 |     |         vaultAddr = p.vault;
 553 |     |     }
 554 |     | 
 555 |     |     function _finalizeLiquidation(
 556 |     |         address user,
 557 |     |         address repayAsset,
 558 |     |         uint256 ar,
 559 |     |         address seizeLst,
 560 |     |         address vaultAddr,
 561 |     |         uint256 shares,
 562 |     |         address to
 563 |     |     ) internal {
 564 |     |         // Seize shares first to prevent DoS when no local cash on spoke
 565 | *   |         ISpokeYieldVault(vaultAddr).onSeizeShares(user, shares, to);
 566 |     |         // Attempt to reduce debt immediately; if there is insufficient local cash on spoke to honor bridge payouts,
 567 |     |         // this hub still accounts for debt reduction by the repaid amount provided by the liquidator off-chain.
 568 |     |         // For cross-chain settlement, the spoke vault can be instructed to bridge liquidity asynchronously.
 569 |     |         uint256 idxRay = marketState[repayAsset].debtIndexRay;
 570 |     |         uint256 actualRepaid = _decreaseDebt(user, repayAsset, idxRay, ar);
 571 |     |         _emitLiquidate(msg.sender, user, repayAsset, actualRepaid, seizeLst, shares);
 572 |     |     }
 573 |     | 
 574 |     |     function _emitLiquidate(
 575 |     |         address liquidator,
 576 |     |         address user,
 577 |     |         address repayAsset,
 578 |     |         uint256 actualRepaid,
 579 |     |         address seizeLst,
 580 |     |         uint256 shares
 581 |     |     ) internal {
 582 |     |         bytes32 aid = _actionId("Liquidate", user, repayAsset, actualRepaid, block.number);
 583 |     |         emit Liquidate(liquidator, user, repayAsset, actualRepaid, seizeLst, shares, LIQ_BONUS_BPS, aid);
 584 |     |     }
 585 |     | 
 586 |     |     /// @notice Set borrow cap for a market.
 587 |     |     function setBorrowCap(address asset, uint256 cap) external onlyRole(GOVERNOR_ROLE) {
 588 |     |         marketParams[asset].borrowCap = SafeCast.toUint128(cap);
 589 |     |         emit BorrowCapSet(asset, cap);
 590 |     |     }
 591 |     | 
 592 |     |     /// @notice Returns account liquidity info: collateral value, debt value, and shortfall (if any), all in 1e18 precision.
 593 |     |     function accountLiquidity(address user, address asset)
 594 |     |         public
 595 |     |         view
 596 |     |         returns (uint256 collateralWad, uint256 debtWad, uint256 shortfallWad)
 597 |     |     {
 598 |     |         MarketParams storage p = marketParams[asset];
 599 |     |         uint256 priceLst1e18 = _price1e18(p.lst);
 600 |     |         uint256 priceAsset1e18 = _price1e18(asset);
 601 |     |         uint256 lstBal = IERC20(p.lst).balanceOf(user);
 602 |     |         collateralWad = Math.mulDiv(lstBal, priceLst1e18, 1e18);
 603 |     |         debtWad = Math.mulDiv(currentDebt(user, asset), priceAsset1e18, 1e18);
 604 |     |         uint256 liqLimit = (collateralWad * uint256(p.liqThresholdBps)) / BPS;
 605 |     |         shortfallWad = debtWad > liqLimit ? debtWad - liqLimit : 0;
 606 |     |     }
 607 |     | 
 608 |     |     /// @notice Returns market state and derived utilization for an asset.
 609 |     |     function marketStateExtended(address asset)
 610 |     |         external
 611 |     |         view
 612 |     |         returns (MarketState memory s, MarketParams memory p, uint256 utilizationRay)
 613 |     |     {
 614 |     |         s = marketState[asset];
 615 |     |         p = marketParams[asset];
 616 |     |         uint256 borrows = uint256(s.totalBorrows);
 617 |     |         utilizationRay = borrows == 0 ? 0 : (borrows * RAY) / (borrows + 1);
 618 |     |     }
 619 |     | 
 620 |     |     uint256[50] private __gap;
 621 |     | }
 622 |     | 

/code/contracts/hub/PriceOracleRouter.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.24;
   3 |     | 
   4 |     | import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
   5 |     | import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
   6 |     | import {AccessControlUpgradeable} from "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
   7 |     | import {PausableUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol";
   8 |     | 
   9 |     | interface IAggregatorV3Like {
  10 |     |     function latestRoundData() external view returns (uint80, int256, uint256, uint256, uint80);
  11 |     | }
  12 |     | 
  13 |     | interface ISequencerUptimeOracleLike {
  14 |     |     function latestRoundData() external view returns (uint80, int256, uint256, uint256, uint80);
  15 |     | }
  16 |     | 
  17 |     | /// @title PriceOracleRouter
  18 |     | /// @notice Price router with per-asset feeds, decimals, and heartbeat staleness checks.
  19 | *   | contract PriceOracleRouter is Initializable, UUPSUpgradeable, AccessControlUpgradeable, PausableUpgradeable {
  20 | *   |     bytes32 public constant GOVERNOR_ROLE = keccak256("GOVERNOR_ROLE");
  21 |     | 
  22 |     |     struct Feed {
  23 |     |         address primary; // chainlink-style aggregator
  24 |     |         address secondary; // optional fallback aggregator
  25 |     |         uint8 decimals; // feed decimals (usually 8)
  26 |     |         uint256 heartbeat; // max age in seconds
  27 |     |         uint256 maxDeviationBps; // acceptable deviation between primary/secondary
  28 |     |         int256 minAnswer; // minimum allowed answer (signed to match CL interface)
  29 |     |         int256 maxAnswer; // maximum allowed answer
  30 |     |     }
  31 |     | 
  32 |     |     mapping(address => Feed) public feedOf;
  33 |     |     address public sequencerOracle; // optional sequencer uptime feed
  34 |     | 
  35 |     |     event FeedSet(
  36 |     |         address indexed asset, address indexed primary, address secondary, uint256 heartbeatSec, uint256 maxDeviationBps
  37 |     |     );
  38 |     |     event SequencerOracleSet(address indexed oracle);
  39 |     |     event GovernorProposed(address indexed currentGovernor, address indexed pendingGovernor);
  40 |     |     event GovernorAccepted(address indexed previousGovernor, address indexed newGovernor);
  41 |     | 
  42 |     |     error StalePrice();
  43 |     |     error ZeroAddress();
  44 |     |     error OutOfBounds();
  45 |     | 
  46 |     |     address public governor;
  47 |     | 
  48 |     |     function initialize(address initialGovernor) external initializer {
  49 |     |         __UUPSUpgradeable_init();
  50 |     |         __AccessControl_init();
  51 |     |         __Pausable_init();
  52 | *   |         _grantRole(DEFAULT_ADMIN_ROLE, initialGovernor);
  53 | *   |         _grantRole(GOVERNOR_ROLE, initialGovernor);
  54 | *   |         governor = initialGovernor;
  55 |     |     }
  56 |     | 
  57 |     |     function _authorizeUpgrade(address) internal override onlyRole(GOVERNOR_ROLE) {}
  58 |     | 
  59 |     |     function setFeed(
  60 |     |         address asset,
  61 |     |         address primary,
  62 |     |         address secondary,
  63 |     |         uint8 decimals,
  64 |     |         uint256 heartbeat,
  65 |     |         uint256 maxDeviationBps
  66 |     |     ) external onlyRole(GOVERNOR_ROLE) {
  67 | *   |         if (asset == address(0) || primary == address(0)) revert ZeroAddress();
  68 | *   |         feedOf[asset] = Feed({
  69 |     |             primary: primary,
  70 |     |             secondary: secondary,
  71 |     |             decimals: decimals,
  72 |     |             heartbeat: heartbeat,
  73 |     |             maxDeviationBps: maxDeviationBps,
  74 |     |             minAnswer: 0,
  75 | *   |             maxAnswer: type(int256).max
  76 |     |         });
  77 | *   |         emit FeedSet(asset, primary, secondary, heartbeat, maxDeviationBps);
  78 |     |     }
  79 |     | 
  80 |     |     function setFeedBounds(address asset, int256 minAnswer, int256 maxAnswer) external onlyRole(GOVERNOR_ROLE) {
  81 |     |         Feed storage f = feedOf[asset];
  82 |     |         if (f.primary == address(0)) revert ZeroAddress();
  83 |     |         f.minAnswer = minAnswer;
  84 |     |         f.maxAnswer = maxAnswer;
  85 |     |     }
  86 |     | 
  87 |     |     function setSequencerOracle(address oracle_) external onlyRole(GOVERNOR_ROLE) {
  88 |     |         sequencerOracle = oracle_;
  89 |     |         emit SequencerOracleSet(oracle_);
  90 |     |     }
  91 |     | 
  92 |     |     function getPrice(address asset) external view returns (uint256 price, uint8 decimals, uint256 lastUpdate) {
  93 | *   |         (price, decimals, lastUpdate) = _checkedPrice(asset);
  94 |     |     }
  95 |     | 
  96 | *   |     function _checkedPrice(address asset) internal view returns (uint256 price, uint8 decimals, uint256 lastUpdate) {
  97 |     |         // Sequencer up check if configured (OP chains)
  98 | *   |         if (sequencerOracle != address(0)) {
  99 |     |             (, int256 up,, uint256 seqUpdated,) = ISequencerUptimeOracleLike(sequencerOracle).latestRoundData();
 100 |     |             if (up == 0) revert StalePrice();
 101 |     |             if (block.timestamp - seqUpdated > 1 hours) revert StalePrice();
 102 |     |         }
 103 |     |         Feed memory f = feedOf[asset];
 104 | *   |         (, int256 a1,, uint256 u1,) = IAggregatorV3Like(f.primary).latestRoundData();
 105 | *   |         bool pFresh = a1 > 0 && (f.heartbeat == 0 || block.timestamp - u1 <= f.heartbeat);
 106 | *   |         bool pBounds = a1 >= f.minAnswer && a1 <= f.maxAnswer;
 107 |     |         uint256 p1u;
 108 | *   |         if (pFresh && pBounds) {
 109 | *   |             p1u = uint256(a1);
 110 |     |         }
 111 | *   |         if (f.secondary != address(0)) {
 112 | *   |             (, int256 a2,, uint256 u2,) = IAggregatorV3Like(f.secondary).latestRoundData();
 113 |     |             bool sFresh = a2 > 0 && (f.heartbeat == 0 || block.timestamp - u2 <= f.heartbeat);
 114 |     |             bool sBounds = a2 >= f.minAnswer && a2 <= f.maxAnswer;
 115 |     |             if (sFresh && sBounds) {
 116 |     |                 if (p1u != 0) {
 117 |     |                     // both fresh and in-bounds: enforce deviation both directions
 118 |     |                     uint256 p2u = uint256(a2);
 119 |     |                     uint256 dev = p1u > p2u ? ((p1u - p2u) * 10_000) / p2u : ((p2u - p1u) * 10_000) / p1u;
 120 |     |                     if (dev > f.maxDeviationBps) revert StalePrice();
 121 |     |                 } else {
 122 |     |                     // primary unusable; use secondary
 123 |     |                     return (uint256(a2), f.decimals, u2);
 124 |     |                 }
 125 |     |             }
 126 |     |         }
 127 | *   |         if (p1u == 0) revert StalePrice();
 128 | *   |         return (p1u, f.decimals, u1);
 129 |     |     }
 130 |     | 
 131 |     |     // --- Two-step governor ---
 132 |     |     address public pendingGovernor;
 133 |     | 
 134 |     |     function proposeGovernor(address newGov) external onlyRole(GOVERNOR_ROLE) {
 135 |     |         if (newGov == address(0)) revert ZeroAddress();
 136 |     |         pendingGovernor = newGov;
 137 |     |         emit GovernorProposed(governor, newGov);
 138 |     |     }
 139 |     | 
 140 |     |     function acceptGovernor() external {
 141 |     |         require(msg.sender == pendingGovernor, "NOT_PENDING");
 142 |     |         address prev = governor;
 143 |     |         _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
 144 |     |         _grantRole(GOVERNOR_ROLE, msg.sender);
 145 |     |         _revokeRole(GOVERNOR_ROLE, prev);
 146 |     |         _revokeRole(DEFAULT_ADMIN_ROLE, prev);
 147 |     |         governor = msg.sender;
 148 |     |         pendingGovernor = address(0);
 149 |     |         emit GovernorAccepted(prev, msg.sender);
 150 |     |     }
 151 |     | 
 152 |     |     uint256[50] private __gap;
 153 |     | }
 154 |     | 

/code/contracts/interfaces/IPriceOracleRouter.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.24;
  3 |     | 
  4 |     | /// @title IPriceOracleRouter
  5 |     | /// @notice Price oracle router interface.
  6 |     | interface IPriceOracleRouter {
  7 |     |     /// @notice Returns the latest price for an asset.
  8 |     |     /// @param asset The asset address.
  9 |     |     /// @return price The price value.
 10 |     |     /// @return decimals The decimals of the price feed.
 11 |     |     /// @return lastUpdate The timestamp of the last update.
 12 |     |     function getPrice(address asset) external view returns (uint256 price, uint8 decimals, uint256 lastUpdate);
 13 |     | }
 14 |     | 

/code/contracts/interfaces/ISpokeYieldVault.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.24;
  3 |     | 
  4 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  5 |     | 
  6 |     | /// @title ISpokeYieldVault
  7 |     | /// @notice ERC4626-like interface with cross-chain hooks for the Spoke vault.
  8 |     | interface ISpokeYieldVault is IERC20 {
  9 |     |     // --- ERC4626 core ---
 10 |     |     function asset() external view returns (address);
 11 |     |     function totalAssets() external view returns (uint256);
 12 |     |     function convertToShares(uint256 assets) external view returns (uint256);
 13 |     |     function convertToAssets(uint256 shares) external view returns (uint256);
 14 |     |     function maxDeposit(address receiver) external view returns (uint256);
 15 |     |     function previewDeposit(uint256 assets) external view returns (uint256);
 16 |     |     function deposit(uint256 assets, address receiver) external returns (uint256);
 17 |     |     function maxMint(address receiver) external view returns (uint256);
 18 |     |     function previewMint(uint256 shares) external view returns (uint256);
 19 |     |     function mint(uint256 shares, address receiver) external returns (uint256);
 20 |     |     function maxWithdraw(address owner) external view returns (uint256);
 21 |     |     function previewWithdraw(uint256 assets) external view returns (uint256);
 22 |     |     function withdraw(uint256 assets, address receiver, address owner) external returns (uint256);
 23 |     |     function maxRedeem(address owner) external view returns (uint256);
 24 |     |     function previewRedeem(uint256 shares) external view returns (uint256);
 25 |     |     function redeem(uint256 shares, address receiver, address owner) external returns (uint256);
 26 |     | 
 27 |     |     // --- Cross-chain hooks ---
 28 |     |     function onRemoteCredit(address user, uint256 assets, uint256 shares, uint256 nonce, bytes32 actionId) external;
 29 |     |     function requestRemoteLiquidity(address toUser, uint256 assets) external;
 30 |     |     function onSeizeShares(address user, uint256 shares, address to) external;
 31 |     | }
 32 |     | 

/code/contracts/mocks/MockAggregator.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.24;
  3 |     | 
  4 | *   | contract MockAggregator {
  5 |     |     int256 public answer;
  6 |     |     uint256 public updatedAt;
  7 |     | 
  8 |     |     constructor(int256 _answer, uint256 _updatedAt) {
  9 |     |         answer = _answer;
 10 |     |         updatedAt = _updatedAt;
 11 |     |     }
 12 |     | 
 13 |     |     function setAnswer(int256 _answer) external {
 14 |     |         answer = _answer;
 15 |     |     }
 16 |     | 
 17 |     |     function setUpdatedAt(uint256 _updatedAt) external {
 18 |     |         updatedAt = _updatedAt;
 19 |     |     }
 20 |     | 
 21 |     |     function latestRoundData() external view returns (uint80, int256, uint256, uint256, uint80) {
 22 | *   |         return (0, answer, updatedAt, updatedAt, 0);
 23 |     |     }
 24 |     | }
 25 |     | 

/code/lib/openzeppelin-contracts-upgradeable/contracts/access/AccessControlUpgradeable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {IAccessControl} from "@openzeppelin/contracts/access/IAccessControl.sol";
   7 |     | import {ContextUpgradeable} from "../utils/ContextUpgradeable.sol";
   8 |     | import {ERC165Upgradeable} from "../utils/introspection/ERC165Upgradeable.sol";
   9 |     | import {Initializable} from "../proxy/utils/Initializable.sol";
  10 |     | 
  11 |     | /**
  12 |     |  * @dev Contract module that allows children to implement role-based access
  13 |     |  * control mechanisms. This is a lightweight version that doesn't allow enumerating role
  14 |     |  * members except through off-chain means by accessing the contract event logs. Some
  15 |     |  * applications may benefit from on-chain enumerability, for those cases see
  16 |     |  * {AccessControlEnumerable}.
  17 |     |  *
  18 |     |  * Roles are referred to by their `bytes32` identifier. These should be exposed
  19 |     |  * in the external API and be unique. The best way to achieve this is by
  20 |     |  * using `public constant` hash digests:
  21 |     |  *
  22 |     |  * ```solidity
  23 |     |  * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");
  24 |     |  * ```
  25 |     |  *
  26 |     |  * Roles can be used to represent a set of permissions. To restrict access to a
  27 |     |  * function call, use {hasRole}:
  28 |     |  *
  29 |     |  * ```solidity
  30 |     |  * function foo() public {
  31 |     |  *     require(hasRole(MY_ROLE, msg.sender));
  32 |     |  *     ...
  33 |     |  * }
  34 |     |  * ```
  35 |     |  *
  36 |     |  * Roles can be granted and revoked dynamically via the {grantRole} and
  37 |     |  * {revokeRole} functions. Each role has an associated admin role, and only
  38 |     |  * accounts that have a role's admin role can call {grantRole} and {revokeRole}.
  39 |     |  *
  40 |     |  * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
  41 |     |  * that only accounts with this role will be able to grant or revoke other
  42 |     |  * roles. More complex role relationships can be created by using
  43 |     |  * {_setRoleAdmin}.
  44 |     |  *
  45 |     |  * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to
  46 |     |  * grant and revoke this role. Extra precautions should be taken to secure
  47 |     |  * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}
  48 |     |  * to enforce additional security measures for this role.
  49 |     |  */
  50 |     | abstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControl, ERC165Upgradeable {
  51 |     |     struct RoleData {
  52 |     |         mapping(address account => bool) hasRole;
  53 |     |         bytes32 adminRole;
  54 |     |     }
  55 |     | 
  56 |     |     bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;
  57 |     | 
  58 |     | 
  59 |     |     /// @custom:storage-location erc7201:openzeppelin.storage.AccessControl
  60 |     |     struct AccessControlStorage {
  61 |     |         mapping(bytes32 role => RoleData) _roles;
  62 |     |     }
  63 |     | 
  64 |     |     // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.AccessControl")) - 1)) & ~bytes32(uint256(0xff))
  65 |     |     bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;
  66 |     | 
  67 |     |     function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {
  68 | *   |         assembly {
  69 |     |             $.slot := AccessControlStorageLocation
  70 |     |         }
  71 |     |     }
  72 |     | 
  73 |     |     /**
  74 |     |      * @dev Modifier that checks that an account has a specific role. Reverts
  75 |     |      * with an {AccessControlUnauthorizedAccount} error including the required role.
  76 |     |      */
  77 |     |     modifier onlyRole(bytes32 role) {
  78 | *   |         _checkRole(role);
  79 |     |         _;
  80 |     |     }
  81 |     | 
  82 |     |     function __AccessControl_init() internal onlyInitializing {
  83 |     |     }
  84 |     | 
  85 |     |     function __AccessControl_init_unchained() internal onlyInitializing {
  86 |     |     }
  87 |     |     /**
  88 |     |      * @dev See {IERC165-supportsInterface}.
  89 |     |      */
  90 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
  91 |     |         return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);
  92 |     |     }
  93 |     | 
  94 |     |     /**
  95 |     |      * @dev Returns `true` if `account` has been granted `role`.
  96 |     |      */
  97 |     |     function hasRole(bytes32 role, address account) public view virtual returns (bool) {
  98 |     |         AccessControlStorage storage $ = _getAccessControlStorage();
  99 |     |         return $._roles[role].hasRole[account];
 100 |     |     }
 101 |     | 
 102 |     |     /**
 103 |     |      * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`
 104 |     |      * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.
 105 |     |      */
 106 | *   |     function _checkRole(bytes32 role) internal view virtual {
 107 |     |         _checkRole(role, _msgSender());
 108 |     |     }
 109 |     | 
 110 |     |     /**
 111 |     |      * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`
 112 |     |      * is missing `role`.
 113 |     |      */
 114 |     |     function _checkRole(bytes32 role, address account) internal view virtual {
 115 | *   |         if (!hasRole(role, account)) {
 116 |     |             revert AccessControlUnauthorizedAccount(account, role);
 117 |     |         }
 118 |     |     }
 119 |     | 
 120 |     |     /**
 121 |     |      * @dev Returns the admin role that controls `role`. See {grantRole} and
 122 |     |      * {revokeRole}.
 123 |     |      *
 124 |     |      * To change a role's admin, use {_setRoleAdmin}.
 125 |     |      */
 126 |     |     function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {
 127 |     |         AccessControlStorage storage $ = _getAccessControlStorage();
 128 |     |         return $._roles[role].adminRole;
 129 |     |     }
 130 |     | 
 131 |     |     /**
 132 |     |      * @dev Grants `role` to `account`.
 133 |     |      *
 134 |     |      * If `account` had not been already granted `role`, emits a {RoleGranted}
 135 |     |      * event.
 136 |     |      *
 137 |     |      * Requirements:
 138 |     |      *
 139 |     |      * - the caller must have ``role``'s admin role.
 140 |     |      *
 141 |     |      * May emit a {RoleGranted} event.
 142 |     |      */
 143 |     |     function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {
 144 |     |         _grantRole(role, account);
 145 |     |     }
 146 |     | 
 147 |     |     /**
 148 |     |      * @dev Revokes `role` from `account`.
 149 |     |      *
 150 |     |      * If `account` had been granted `role`, emits a {RoleRevoked} event.
 151 |     |      *
 152 |     |      * Requirements:
 153 |     |      *
 154 |     |      * - the caller must have ``role``'s admin role.
 155 |     |      *
 156 |     |      * May emit a {RoleRevoked} event.
 157 |     |      */
 158 |     |     function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {
 159 |     |         _revokeRole(role, account);
 160 |     |     }
 161 |     | 
 162 |     |     /**
 163 |     |      * @dev Revokes `role` from the calling account.
 164 |     |      *
 165 |     |      * Roles are often managed via {grantRole} and {revokeRole}: this function's
 166 |     |      * purpose is to provide a mechanism for accounts to lose their privileges
 167 |     |      * if they are compromised (such as when a trusted device is misplaced).
 168 |     |      *
 169 |     |      * If the calling account had been revoked `role`, emits a {RoleRevoked}
 170 |     |      * event.
 171 |     |      *
 172 |     |      * Requirements:
 173 |     |      *
 174 |     |      * - the caller must be `callerConfirmation`.
 175 |     |      *
 176 |     |      * May emit a {RoleRevoked} event.
 177 |     |      */
 178 |     |     function renounceRole(bytes32 role, address callerConfirmation) public virtual {
 179 |     |         if (callerConfirmation != _msgSender()) {
 180 |     |             revert AccessControlBadConfirmation();
 181 |     |         }
 182 |     | 
 183 |     |         _revokeRole(role, callerConfirmation);
 184 |     |     }
 185 |     | 
 186 |     |     /**
 187 |     |      * @dev Sets `adminRole` as ``role``'s admin role.
 188 |     |      *
 189 |     |      * Emits a {RoleAdminChanged} event.
 190 |     |      */
 191 |     |     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
 192 |     |         AccessControlStorage storage $ = _getAccessControlStorage();
 193 |     |         bytes32 previousAdminRole = getRoleAdmin(role);
 194 |     |         $._roles[role].adminRole = adminRole;
 195 |     |         emit RoleAdminChanged(role, previousAdminRole, adminRole);
 196 |     |     }
 197 |     | 
 198 |     |     /**
 199 |     |      * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.
 200 |     |      *
 201 |     |      * Internal function without access restriction.
 202 |     |      *
 203 |     |      * May emit a {RoleGranted} event.
 204 |     |      */
 205 | *   |     function _grantRole(bytes32 role, address account) internal virtual returns (bool) {
 206 |     |         AccessControlStorage storage $ = _getAccessControlStorage();
 207 |     |         if (!hasRole(role, account)) {
 208 | *   |             $._roles[role].hasRole[account] = true;
 209 | *   |             emit RoleGranted(role, account, _msgSender());
 210 | *   |             return true;
 211 |     |         } else {
 212 |     |             return false;
 213 |     |         }
 214 |     |     }
 215 |     | 
 216 |     |     /**
 217 |     |      * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.
 218 |     |      *
 219 |     |      * Internal function without access restriction.
 220 |     |      *
 221 |     |      * May emit a {RoleRevoked} event.
 222 |     |      */
 223 |     |     function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {
 224 |     |         AccessControlStorage storage $ = _getAccessControlStorage();
 225 |     |         if (hasRole(role, account)) {
 226 |     |             $._roles[role].hasRole[account] = false;
 227 |     |             emit RoleRevoked(role, account, _msgSender());
 228 |     |             return true;
 229 |     |         } else {
 230 |     |             return false;
 231 |     |         }
 232 |     |     }
 233 |     | }
 234 |     | 

/code/lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed
   8 |     |  * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an
   9 |     |  * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer
  10 |     |  * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.
  11 |     |  *
  12 |     |  * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be
  13 |     |  * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in
  14 |     |  * case an upgrade adds a module that needs to be initialized.
  15 |     |  *
  16 |     |  * For example:
  17 |     |  *
  18 |     |  * [.hljs-theme-light.nopadding]
  19 |     |  * ```solidity
  20 |     |  * contract MyToken is ERC20Upgradeable {
  21 |     |  *     function initialize() initializer public {
  22 |     |  *         __ERC20_init("MyToken", "MTK");
  23 |     |  *     }
  24 |     |  * }
  25 |     |  *
  26 |     |  * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {
  27 |     |  *     function initializeV2() reinitializer(2) public {
  28 |     |  *         __ERC20Permit_init("MyToken");
  29 |     |  *     }
  30 |     |  * }
  31 |     |  * ```
  32 |     |  *
  33 |     |  * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as
  34 |     |  * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.
  35 |     |  *
  36 |     |  * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure
  37 |     |  * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.
  38 |     |  *
  39 |     |  * [CAUTION]
  40 |     |  * ====
  41 |     |  * Avoid leaving a contract uninitialized.
  42 |     |  *
  43 |     |  * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation
  44 |     |  * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke
  45 |     |  * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:
  46 |     |  *
  47 |     |  * [.hljs-theme-light.nopadding]
  48 |     |  * ```
  49 |     |  * /// @custom:oz-upgrades-unsafe-allow constructor
  50 |     |  * constructor() {
  51 |     |  *     _disableInitializers();
  52 |     |  * }
  53 |     |  * ```
  54 |     |  * ====
  55 |     |  */
  56 |     | abstract contract Initializable {
  57 |     |     /**
  58 |     |      * @dev Storage of the initializable contract.
  59 |     |      *
  60 |     |      * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions
  61 |     |      * when using with upgradeable contracts.
  62 |     |      *
  63 |     |      * @custom:storage-location erc7201:openzeppelin.storage.Initializable
  64 |     |      */
  65 |     |     struct InitializableStorage {
  66 |     |         /**
  67 |     |          * @dev Indicates that the contract has been initialized.
  68 |     |          */
  69 |     |         uint64 _initialized;
  70 |     |         /**
  71 |     |          * @dev Indicates that the contract is in the process of being initialized.
  72 |     |          */
  73 |     |         bool _initializing;
  74 |     |     }
  75 |     | 
  76 |     |     // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))
  77 |     |     bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;
  78 |     | 
  79 |     |     /**
  80 |     |      * @dev The contract is already initialized.
  81 |     |      */
  82 |     |     error InvalidInitialization();
  83 |     | 
  84 |     |     /**
  85 |     |      * @dev The contract is not initializing.
  86 |     |      */
  87 |     |     error NotInitializing();
  88 |     | 
  89 |     |     /**
  90 |     |      * @dev Triggered when the contract has been initialized or reinitialized.
  91 |     |      */
  92 |     |     event Initialized(uint64 version);
  93 |     | 
  94 |     |     /**
  95 |     |      * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,
  96 |     |      * `onlyInitializing` functions can be used to initialize parent contracts.
  97 |     |      *
  98 |     |      * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any
  99 |     |      * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in
 100 |     |      * production.
 101 |     |      *
 102 |     |      * Emits an {Initialized} event.
 103 |     |      */
 104 |     |     modifier initializer() {
 105 |     |         // solhint-disable-next-line var-name-mixedcase
 106 |     |         InitializableStorage storage $ = _getInitializableStorage();
 107 |     | 
 108 |     |         // Cache values to avoid duplicated sloads
 109 | *   |         bool isTopLevelCall = !$._initializing;
 110 |     |         uint64 initialized = $._initialized;
 111 |     | 
 112 |     |         // Allowed calls:
 113 |     |         // - initialSetup: the contract is not in the initializing state and no previous version was
 114 |     |         //                 initialized
 115 |     |         // - construction: the contract is initialized at version 1 (no reininitialization) and the
 116 |     |         //                 current contract is just being deployed
 117 | *   |         bool initialSetup = initialized == 0 && isTopLevelCall;
 118 | *   |         bool construction = initialized == 1 && address(this).code.length == 0;
 119 |     | 
 120 | *   |         if (!initialSetup && !construction) {
 121 |     |             revert InvalidInitialization();
 122 |     |         }
 123 |     |         $._initialized = 1;
 124 | *   |         if (isTopLevelCall) {
 125 |     |             $._initializing = true;
 126 |     |         }
 127 |     |         _;
 128 | *   |         if (isTopLevelCall) {
 129 |     |             $._initializing = false;
 130 | *   |             emit Initialized(1);
 131 |     |         }
 132 |     |     }
 133 |     | 
 134 |     |     /**
 135 |     |      * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the
 136 |     |      * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be
 137 |     |      * used to initialize parent contracts.
 138 |     |      *
 139 |     |      * A reinitializer may be used after the original initialization step. This is essential to configure modules that
 140 |     |      * are added through upgrades and that require initialization.
 141 |     |      *
 142 |     |      * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`
 143 |     |      * cannot be nested. If one is invoked in the context of another, execution will revert.
 144 |     |      *
 145 |     |      * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in
 146 |     |      * a contract, executing them in the right order is up to the developer or operator.
 147 |     |      *
 148 |     |      * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.
 149 |     |      *
 150 |     |      * Emits an {Initialized} event.
 151 |     |      */
 152 |     |     modifier reinitializer(uint64 version) {
 153 |     |         // solhint-disable-next-line var-name-mixedcase
 154 |     |         InitializableStorage storage $ = _getInitializableStorage();
 155 |     | 
 156 |     |         if ($._initializing || $._initialized >= version) {
 157 |     |             revert InvalidInitialization();
 158 |     |         }
 159 |     |         $._initialized = version;
 160 |     |         $._initializing = true;
 161 |     |         _;
 162 |     |         $._initializing = false;
 163 |     |         emit Initialized(version);
 164 |     |     }
 165 |     | 
 166 |     |     /**
 167 |     |      * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the
 168 |     |      * {initializer} and {reinitializer} modifiers, directly or indirectly.
 169 |     |      */
 170 | *   |     modifier onlyInitializing() {
 171 |     |         _checkInitializing();
 172 |     |         _;
 173 |     |     }
 174 |     | 
 175 |     |     /**
 176 |     |      * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.
 177 |     |      */
 178 | *   |     function _checkInitializing() internal view virtual {
 179 | *   |         if (!_isInitializing()) {
 180 |     |             revert NotInitializing();
 181 |     |         }
 182 |     |     }
 183 |     | 
 184 |     |     /**
 185 |     |      * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.
 186 |     |      * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized
 187 |     |      * to any version. It is recommended to use this to lock implementation contracts that are designed to be called
 188 |     |      * through proxies.
 189 |     |      *
 190 |     |      * Emits an {Initialized} event the first time it is successfully executed.
 191 |     |      */
 192 |     |     function _disableInitializers() internal virtual {
 193 |     |         // solhint-disable-next-line var-name-mixedcase
 194 |     |         InitializableStorage storage $ = _getInitializableStorage();
 195 |     | 
 196 |     |         if ($._initializing) {
 197 |     |             revert InvalidInitialization();
 198 |     |         }
 199 |     |         if ($._initialized != type(uint64).max) {
 200 |     |             $._initialized = type(uint64).max;
 201 |     |             emit Initialized(type(uint64).max);
 202 |     |         }
 203 |     |     }
 204 |     | 
 205 |     |     /**
 206 |     |      * @dev Returns the highest version that has been initialized. See {reinitializer}.
 207 |     |      */
 208 |     |     function _getInitializedVersion() internal view returns (uint64) {
 209 |     |         return _getInitializableStorage()._initialized;
 210 |     |     }
 211 |     | 
 212 |     |     /**
 213 |     |      * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.
 214 |     |      */
 215 |     |     function _isInitializing() internal view returns (bool) {
 216 |     |         return _getInitializableStorage()._initializing;
 217 |     |     }
 218 |     | 
 219 |     |     /**
 220 |     |      * @dev Returns a pointer to the storage namespace.
 221 |     |      */
 222 |     |     // solhint-disable-next-line var-name-mixedcase
 223 |     |     function _getInitializableStorage() private pure returns (InitializableStorage storage $) {
 224 | *   |         assembly {
 225 |     |             $.slot := INITIALIZABLE_STORAGE
 226 |     |         }
 227 |     |     }
 228 |     | }
 229 |     | 

/code/lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/UUPSUpgradeable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/UUPSUpgradeable.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {IERC1822Proxiable} from "@openzeppelin/contracts/interfaces/draft-IERC1822.sol";
   7 |     | import {ERC1967Utils} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol";
   8 |     | import {Initializable} from "./Initializable.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an
  12 |     |  * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.
  13 |     |  *
  14 |     |  * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is
  15 |     |  * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing
  16 |     |  * `UUPSUpgradeable` with a custom implementation of upgrades.
  17 |     |  *
  18 |     |  * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.
  19 |     |  */
  20 |     | abstract contract UUPSUpgradeable is Initializable, IERC1822Proxiable {
  21 |     |     /// @custom:oz-upgrades-unsafe-allow state-variable-immutable
  22 | *   |     address private immutable __self = address(this);
  23 |     | 
  24 |     |     /**
  25 |     |      * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`
  26 |     |      * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,
  27 |     |      * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.
  28 |     |      * If the getter returns `"5.0.0"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must
  29 |     |      * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function
  30 |     |      * during an upgrade.
  31 |     |      */
  32 |     |     string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";
  33 |     | 
  34 |     |     /**
  35 |     |      * @dev The call is from an unauthorized context.
  36 |     |      */
  37 |     |     error UUPSUnauthorizedCallContext();
  38 |     | 
  39 |     |     /**
  40 |     |      * @dev The storage `slot` is unsupported as a UUID.
  41 |     |      */
  42 |     |     error UUPSUnsupportedProxiableUUID(bytes32 slot);
  43 |     | 
  44 |     |     /**
  45 |     |      * @dev Check that the execution is being performed through a delegatecall call and that the execution context is
  46 |     |      * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case
  47 |     |      * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a
  48 |     |      * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to
  49 |     |      * fail.
  50 |     |      */
  51 |     |     modifier onlyProxy() {
  52 |     |         _checkProxy();
  53 |     |         _;
  54 |     |     }
  55 |     | 
  56 |     |     /**
  57 |     |      * @dev Check that the execution is not being performed through a delegate call. This allows a function to be
  58 |     |      * callable on the implementing contract but not through proxies.
  59 |     |      */
  60 |     |     modifier notDelegated() {
  61 |     |         _checkNotDelegated();
  62 |     |         _;
  63 |     |     }
  64 |     | 
  65 |     |     function __UUPSUpgradeable_init() internal onlyInitializing {
  66 |     |     }
  67 |     | 
  68 |     |     function __UUPSUpgradeable_init_unchained() internal onlyInitializing {
  69 |     |     }
  70 |     |     /**
  71 |     |      * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the
  72 |     |      * implementation. It is used to validate the implementation's compatibility when performing an upgrade.
  73 |     |      *
  74 |     |      * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks
  75 |     |      * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this
  76 |     |      * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.
  77 |     |      */
  78 |     |     function proxiableUUID() external view virtual notDelegated returns (bytes32) {
  79 |     |         return ERC1967Utils.IMPLEMENTATION_SLOT;
  80 |     |     }
  81 |     | 
  82 |     |     /**
  83 |     |      * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call
  84 |     |      * encoded in `data`.
  85 |     |      *
  86 |     |      * Calls {_authorizeUpgrade}.
  87 |     |      *
  88 |     |      * Emits an {Upgraded} event.
  89 |     |      *
  90 |     |      * @custom:oz-upgrades-unsafe-allow-reachable delegatecall
  91 |     |      */
  92 |     |     function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {
  93 |     |         _authorizeUpgrade(newImplementation);
  94 |     |         _upgradeToAndCallUUPS(newImplementation, data);
  95 |     |     }
  96 |     | 
  97 |     |     /**
  98 |     |      * @dev Reverts if the execution is not performed via delegatecall or the execution
  99 |     |      * context is not of a proxy with an ERC1967-compliant implementation pointing to self.
 100 |     |      * See {_onlyProxy}.
 101 |     |      */
 102 |     |     function _checkProxy() internal view virtual {
 103 |     |         if (
 104 |     |             address(this) == __self || // Must be called through delegatecall
 105 |     |             ERC1967Utils.getImplementation() != __self // Must be called through an active proxy
 106 |     |         ) {
 107 |     |             revert UUPSUnauthorizedCallContext();
 108 |     |         }
 109 |     |     }
 110 |     | 
 111 |     |     /**
 112 |     |      * @dev Reverts if the execution is performed via delegatecall.
 113 |     |      * See {notDelegated}.
 114 |     |      */
 115 |     |     function _checkNotDelegated() internal view virtual {
 116 |     |         if (address(this) != __self) {
 117 |     |             // Must not be called through delegatecall
 118 |     |             revert UUPSUnauthorizedCallContext();
 119 |     |         }
 120 |     |     }
 121 |     | 
 122 |     |     /**
 123 |     |      * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by
 124 |     |      * {upgradeToAndCall}.
 125 |     |      *
 126 |     |      * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.
 127 |     |      *
 128 |     |      * ```solidity
 129 |     |      * function _authorizeUpgrade(address) internal onlyOwner {}
 130 |     |      * ```
 131 |     |      */
 132 |     |     function _authorizeUpgrade(address newImplementation) internal virtual;
 133 |     | 
 134 |     |     /**
 135 |     |      * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.
 136 |     |      *
 137 |     |      * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value
 138 |     |      * is expected to be the implementation slot in ERC1967.
 139 |     |      *
 140 |     |      * Emits an {IERC1967-Upgraded} event.
 141 |     |      */
 142 |     |     function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {
 143 |     |         try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {
 144 |     |             if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {
 145 |     |                 revert UUPSUnsupportedProxiableUUID(slot);
 146 |     |             }
 147 |     |             ERC1967Utils.upgradeToAndCall(newImplementation, data);
 148 |     |         } catch {
 149 |     |             // The implementation is not UUPS
 150 |     |             revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);
 151 |     |         }
 152 |     |     }
 153 |     | }
 154 |     | 

/code/lib/openzeppelin-contracts-upgradeable/contracts/utils/ContextUpgradeable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | import {Initializable} from "../proxy/utils/Initializable.sol";
  6 |     | 
  7 |     | /**
  8 |     |  * @dev Provides information about the current execution context, including the
  9 |     |  * sender of the transaction and its data. While these are generally available
 10 |     |  * via msg.sender and msg.data, they should not be accessed in such a direct
 11 |     |  * manner, since when dealing with meta-transactions the account sending and
 12 |     |  * paying for execution may not be the actual sender (as far as an application
 13 |     |  * is concerned).
 14 |     |  *
 15 |     |  * This contract is only required for intermediate, library-like contracts.
 16 |     |  */
 17 |     | abstract contract ContextUpgradeable is Initializable {
 18 |     |     function __Context_init() internal onlyInitializing {
 19 |     |     }
 20 |     | 
 21 |     |     function __Context_init_unchained() internal onlyInitializing {
 22 |     |     }
 23 |     |     function _msgSender() internal view virtual returns (address) {
 24 | *   |         return msg.sender;
 25 |     |     }
 26 |     | 
 27 |     |     function _msgData() internal view virtual returns (bytes calldata) {
 28 |     |         return msg.data;
 29 |     |     }
 30 |     | 
 31 |     |     function _contextSuffixLength() internal view virtual returns (uint256) {
 32 |     |         return 0;
 33 |     |     }
 34 |     | }
 35 |     | 

/code/lib/openzeppelin-contracts-upgradeable/contracts/utils/PausableUpgradeable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {ContextUpgradeable} from "../utils/ContextUpgradeable.sol";
   7 |     | import {Initializable} from "../proxy/utils/Initializable.sol";
   8 |     | 
   9 |     | /**
  10 |     |  * @dev Contract module which allows children to implement an emergency stop
  11 |     |  * mechanism that can be triggered by an authorized account.
  12 |     |  *
  13 |     |  * This module is used through inheritance. It will make available the
  14 |     |  * modifiers `whenNotPaused` and `whenPaused`, which can be applied to
  15 |     |  * the functions of your contract. Note that they will not be pausable by
  16 |     |  * simply including this module, only once the modifiers are put in place.
  17 |     |  */
  18 |     | abstract contract PausableUpgradeable is Initializable, ContextUpgradeable {
  19 |     |     /// @custom:storage-location erc7201:openzeppelin.storage.Pausable
  20 |     |     struct PausableStorage {
  21 |     |         bool _paused;
  22 |     |     }
  23 |     | 
  24 |     |     // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Pausable")) - 1)) & ~bytes32(uint256(0xff))
  25 |     |     bytes32 private constant PausableStorageLocation = 0xcd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f03300;
  26 |     | 
  27 |     |     function _getPausableStorage() private pure returns (PausableStorage storage $) {
  28 | *   |         assembly {
  29 |     |             $.slot := PausableStorageLocation
  30 |     |         }
  31 |     |     }
  32 |     | 
  33 |     |     /**
  34 |     |      * @dev Emitted when the pause is triggered by `account`.
  35 |     |      */
  36 |     |     event Paused(address account);
  37 |     | 
  38 |     |     /**
  39 |     |      * @dev Emitted when the pause is lifted by `account`.
  40 |     |      */
  41 |     |     event Unpaused(address account);
  42 |     | 
  43 |     |     /**
  44 |     |      * @dev The operation failed because the contract is paused.
  45 |     |      */
  46 |     |     error EnforcedPause();
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev The operation failed because the contract is not paused.
  50 |     |      */
  51 |     |     error ExpectedPause();
  52 |     | 
  53 |     |     /**
  54 |     |      * @dev Initializes the contract in unpaused state.
  55 |     |      */
  56 |     |     function __Pausable_init() internal onlyInitializing {
  57 |     |         __Pausable_init_unchained();
  58 |     |     }
  59 |     | 
  60 |     |     function __Pausable_init_unchained() internal onlyInitializing {
  61 |     |         PausableStorage storage $ = _getPausableStorage();
  62 |     |         $._paused = false;
  63 |     |     }
  64 |     | 
  65 |     |     /**
  66 |     |      * @dev Modifier to make a function callable only when the contract is not paused.
  67 |     |      *
  68 |     |      * Requirements:
  69 |     |      *
  70 |     |      * - The contract must not be paused.
  71 |     |      */
  72 | *   |     modifier whenNotPaused() {
  73 |     |         _requireNotPaused();
  74 | *   |         _;
  75 |     |     }
  76 |     | 
  77 |     |     /**
  78 |     |      * @dev Modifier to make a function callable only when the contract is paused.
  79 |     |      *
  80 |     |      * Requirements:
  81 |     |      *
  82 |     |      * - The contract must be paused.
  83 |     |      */
  84 |     |     modifier whenPaused() {
  85 |     |         _requirePaused();
  86 |     |         _;
  87 |     |     }
  88 |     | 
  89 |     |     /**
  90 |     |      * @dev Returns true if the contract is paused, and false otherwise.
  91 |     |      */
  92 |     |     function paused() public view virtual returns (bool) {
  93 |     |         PausableStorage storage $ = _getPausableStorage();
  94 |     |         return $._paused;
  95 |     |     }
  96 |     | 
  97 |     |     /**
  98 |     |      * @dev Throws if the contract is paused.
  99 |     |      */
 100 | *   |     function _requireNotPaused() internal view virtual {
 101 | *   |         if (paused()) {
 102 |     |             revert EnforcedPause();
 103 |     |         }
 104 |     |     }
 105 |     | 
 106 |     |     /**
 107 |     |      * @dev Throws if the contract is not paused.
 108 |     |      */
 109 |     |     function _requirePaused() internal view virtual {
 110 |     |         if (!paused()) {
 111 |     |             revert ExpectedPause();
 112 |     |         }
 113 |     |     }
 114 |     | 
 115 |     |     /**
 116 |     |      * @dev Triggers stopped state.
 117 |     |      *
 118 |     |      * Requirements:
 119 |     |      *
 120 |     |      * - The contract must not be paused.
 121 |     |      */
 122 |     |     function _pause() internal virtual whenNotPaused {
 123 |     |         PausableStorage storage $ = _getPausableStorage();
 124 |     |         $._paused = true;
 125 |     |         emit Paused(_msgSender());
 126 |     |     }
 127 |     | 
 128 |     |     /**
 129 |     |      * @dev Returns to normal state.
 130 |     |      *
 131 |     |      * Requirements:
 132 |     |      *
 133 |     |      * - The contract must be paused.
 134 |     |      */
 135 |     |     function _unpause() internal virtual whenPaused {
 136 |     |         PausableStorage storage $ = _getPausableStorage();
 137 |     |         $._paused = false;
 138 |     |         emit Unpaused(_msgSender());
 139 |     |     }
 140 |     | }
 141 |     | 

/code/lib/openzeppelin-contracts-upgradeable/contracts/utils/ReentrancyGuardUpgradeable.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | import {Initializable} from "../proxy/utils/Initializable.sol";
   6 |     | 
   7 |     | /**
   8 |     |  * @dev Contract module that helps prevent reentrant calls to a function.
   9 |     |  *
  10 |     |  * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
  11 |     |  * available, which can be applied to functions to make sure there are no nested
  12 |     |  * (reentrant) calls to them.
  13 |     |  *
  14 |     |  * Note that because there is a single `nonReentrant` guard, functions marked as
  15 |     |  * `nonReentrant` may not call one another. This can be worked around by making
  16 |     |  * those functions `private`, and then adding `external` `nonReentrant` entry
  17 |     |  * points to them.
  18 |     |  *
  19 |     |  * TIP: If you would like to learn more about reentrancy and alternative ways
  20 |     |  * to protect against it, check out our blog post
  21 |     |  * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
  22 |     |  */
  23 |     | abstract contract ReentrancyGuardUpgradeable is Initializable {
  24 |     |     // Booleans are more expensive than uint256 or any type that takes up a full
  25 |     |     // word because each write operation emits an extra SLOAD to first read the
  26 |     |     // slot's contents, replace the bits taken up by the boolean, and then write
  27 |     |     // back. This is the compiler's defense against contract upgrades and
  28 |     |     // pointer aliasing, and it cannot be disabled.
  29 |     | 
  30 |     |     // The values being non-zero value makes deployment a bit more expensive,
  31 |     |     // but in exchange the refund on every call to nonReentrant will be lower in
  32 |     |     // amount. Since refunds are capped to a percentage of the total
  33 |     |     // transaction's gas, it is best to keep them low in cases like this one, to
  34 |     |     // increase the likelihood of the full refund coming into effect.
  35 | *   |     uint256 private constant NOT_ENTERED = 1;
  36 | *   |     uint256 private constant ENTERED = 2;
  37 |     | 
  38 |     |     /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard
  39 |     |     struct ReentrancyGuardStorage {
  40 |     |         uint256 _status;
  41 |     |     }
  42 |     | 
  43 |     |     // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.ReentrancyGuard")) - 1)) & ~bytes32(uint256(0xff))
  44 |     |     bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;
  45 |     | 
  46 |     |     function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {
  47 |     |         assembly {
  48 |     |             $.slot := ReentrancyGuardStorageLocation
  49 |     |         }
  50 |     |     }
  51 |     | 
  52 |     |     /**
  53 |     |      * @dev Unauthorized reentrant call.
  54 |     |      */
  55 |     |     error ReentrancyGuardReentrantCall();
  56 |     | 
  57 |     |     function __ReentrancyGuard_init() internal onlyInitializing {
  58 |     |         __ReentrancyGuard_init_unchained();
  59 |     |     }
  60 |     | 
  61 |     |     function __ReentrancyGuard_init_unchained() internal onlyInitializing {
  62 |     |         ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();
  63 |     |         $._status = NOT_ENTERED;
  64 |     |     }
  65 |     | 
  66 |     |     /**
  67 |     |      * @dev Prevents a contract from calling itself, directly or indirectly.
  68 |     |      * Calling a `nonReentrant` function from another `nonReentrant`
  69 |     |      * function is not supported. It is possible to prevent this from happening
  70 |     |      * by making the `nonReentrant` function external, and making it call a
  71 |     |      * `private` function that does the actual work.
  72 |     |      */
  73 | *   |     modifier nonReentrant() {
  74 |     |         _nonReentrantBefore();
  75 |     |         _;
  76 |     |         _nonReentrantAfter();
  77 |     |     }
  78 |     | 
  79 | *   |     function _nonReentrantBefore() private {
  80 |     |         ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();
  81 |     |         // On the first call to nonReentrant, _status will be NOT_ENTERED
  82 | *   |         if ($._status == ENTERED) {
  83 |     |             revert ReentrancyGuardReentrantCall();
  84 |     |         }
  85 |     | 
  86 |     |         // Any calls to nonReentrant after this point will fail
  87 |     |         $._status = ENTERED;
  88 |     |     }
  89 |     | 
  90 |     |     function _nonReentrantAfter() private {
  91 |     |         ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();
  92 |     |         // By storing the original value once again, a refund is triggered (see
  93 |     |         // https://eips.ethereum.org/EIPS/eip-2200)
  94 |     |         $._status = NOT_ENTERED;
  95 |     |     }
  96 |     | 
  97 |     |     /**
  98 |     |      * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a
  99 |     |      * `nonReentrant` function in the call stack.
 100 |     |      */
 101 |     |     function _reentrancyGuardEntered() internal view returns (bool) {
 102 |     |         ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();
 103 |     |         return $._status == ENTERED;
 104 |     |     }
 105 |     | }
 106 |     | 

/code/lib/openzeppelin-contracts-upgradeable/contracts/utils/introspection/ERC165Upgradeable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | import {IERC165} from "@openzeppelin/contracts/utils/introspection/IERC165.sol";
  7 |     | import {Initializable} from "../../proxy/utils/Initializable.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @dev Implementation of the {IERC165} interface.
 11 |     |  *
 12 |     |  * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
 13 |     |  * for the additional interface id that will be supported. For example:
 14 |     |  *
 15 |     |  * ```solidity
 16 |     |  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 17 |     |  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 18 |     |  * }
 19 |     |  * ```
 20 |     |  */
 21 |     | abstract contract ERC165Upgradeable is Initializable, IERC165 {
 22 |     |     function __ERC165_init() internal onlyInitializing {
 23 |     |     }
 24 |     | 
 25 |     |     function __ERC165_init_unchained() internal onlyInitializing {
 26 |     |     }
 27 |     |     /**
 28 |     |      * @dev See {IERC165-supportsInterface}.
 29 |     |      */
 30 |     |     function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {
 31 |     |         return interfaceId == type(IERC165).interfaceId;
 32 |     |     }
 33 |     | }
 34 |     | 

/code/lib/openzeppelin-contracts/contracts/access/IAccessControl.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev External interface of AccessControl declared to support ERC165 detection.
   8 |     |  */
   9 |     | interface IAccessControl {
  10 |     |     /**
  11 |     |      * @dev The `account` is missing a role.
  12 |     |      */
  13 |     |     error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
  14 |     | 
  15 |     |     /**
  16 |     |      * @dev The caller of a function is not the expected one.
  17 |     |      *
  18 |     |      * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.
  19 |     |      */
  20 |     |     error AccessControlBadConfirmation();
  21 |     | 
  22 |     |     /**
  23 |     |      * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`
  24 |     |      *
  25 |     |      * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
  26 |     |      * {RoleAdminChanged} not being emitted signaling this.
  27 |     |      */
  28 |     |     event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Emitted when `account` is granted `role`.
  32 |     |      *
  33 |     |      * `sender` is the account that originated the contract call, an admin role
  34 |     |      * bearer except when using {AccessControl-_setupRole}.
  35 |     |      */
  36 |     |     event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
  37 |     | 
  38 |     |     /**
  39 |     |      * @dev Emitted when `account` is revoked `role`.
  40 |     |      *
  41 |     |      * `sender` is the account that originated the contract call:
  42 |     |      *   - if using `revokeRole`, it is the admin role bearer
  43 |     |      *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
  44 |     |      */
  45 |     |     event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
  46 |     | 
  47 |     |     /**
  48 |     |      * @dev Returns `true` if `account` has been granted `role`.
  49 |     |      */
  50 |     |     function hasRole(bytes32 role, address account) external view returns (bool);
  51 |     | 
  52 |     |     /**
  53 |     |      * @dev Returns the admin role that controls `role`. See {grantRole} and
  54 |     |      * {revokeRole}.
  55 |     |      *
  56 |     |      * To change a role's admin, use {AccessControl-_setRoleAdmin}.
  57 |     |      */
  58 |     |     function getRoleAdmin(bytes32 role) external view returns (bytes32);
  59 |     | 
  60 |     |     /**
  61 |     |      * @dev Grants `role` to `account`.
  62 |     |      *
  63 |     |      * If `account` had not been already granted `role`, emits a {RoleGranted}
  64 |     |      * event.
  65 |     |      *
  66 |     |      * Requirements:
  67 |     |      *
  68 |     |      * - the caller must have ``role``'s admin role.
  69 |     |      */
  70 |     |     function grantRole(bytes32 role, address account) external;
  71 |     | 
  72 |     |     /**
  73 |     |      * @dev Revokes `role` from `account`.
  74 |     |      *
  75 |     |      * If `account` had been granted `role`, emits a {RoleRevoked} event.
  76 |     |      *
  77 |     |      * Requirements:
  78 |     |      *
  79 |     |      * - the caller must have ``role``'s admin role.
  80 |     |      */
  81 |     |     function revokeRole(bytes32 role, address account) external;
  82 |     | 
  83 |     |     /**
  84 |     |      * @dev Revokes `role` from the calling account.
  85 |     |      *
  86 |     |      * Roles are often managed via {grantRole} and {revokeRole}: this function's
  87 |     |      * purpose is to provide a mechanism for accounts to lose their privileges
  88 |     |      * if they are compromised (such as when a trusted device is misplaced).
  89 |     |      *
  90 |     |      * If the calling account had been granted `role`, emits a {RoleRevoked}
  91 |     |      * event.
  92 |     |      *
  93 |     |      * Requirements:
  94 |     |      *
  95 |     |      * - the caller must be `callerConfirmation`.
  96 |     |      */
  97 |     |     function renounceRole(bytes32 role, address callerConfirmation) external;
  98 |     | }
  99 |     | 

/code/lib/openzeppelin-contracts/contracts/interfaces/draft-IERC1822.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC1822.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified
  8 |     |  * proxy whose upgrades are fully controlled by the current implementation.
  9 |     |  */
 10 |     | interface IERC1822Proxiable {
 11 |     |     /**
 12 |     |      * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation
 13 |     |      * address.
 14 |     |      *
 15 |     |      * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks
 16 |     |      * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this
 17 |     |      * function revert if invoked through a proxy.
 18 |     |      */
 19 |     |     function proxiableUUID() external view returns (bytes32);
 20 |     | }
 21 |     | 

/code/lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Utils.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (proxy/ERC1967/ERC1967Utils.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {IBeacon} from "../beacon/IBeacon.sol";
   7 |     | import {Address} from "../../utils/Address.sol";
   8 |     | import {StorageSlot} from "../../utils/StorageSlot.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @dev This abstract contract provides getters and event emitting update functions for
  12 |     |  * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.
  13 |     |  */
  14 |     | library ERC1967Utils {
  15 |     |     // We re-declare ERC-1967 events here because they can't be used directly from IERC1967.
  16 |     |     // This will be fixed in Solidity 0.8.21. At that point we should remove these events.
  17 |     |     /**
  18 |     |      * @dev Emitted when the implementation is upgraded.
  19 |     |      */
  20 |     |     event Upgraded(address indexed implementation);
  21 |     | 
  22 |     |     /**
  23 |     |      * @dev Emitted when the admin account has changed.
  24 |     |      */
  25 |     |     event AdminChanged(address previousAdmin, address newAdmin);
  26 |     | 
  27 |     |     /**
  28 |     |      * @dev Emitted when the beacon is changed.
  29 |     |      */
  30 |     |     event BeaconUpgraded(address indexed beacon);
  31 |     | 
  32 |     |     /**
  33 |     |      * @dev Storage slot with the address of the current implementation.
  34 |     |      * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1.
  35 |     |      */
  36 |     |     // solhint-disable-next-line private-vars-leading-underscore
  37 |     |     bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
  38 |     | 
  39 |     |     /**
  40 |     |      * @dev The `implementation` of the proxy is invalid.
  41 |     |      */
  42 |     |     error ERC1967InvalidImplementation(address implementation);
  43 |     | 
  44 |     |     /**
  45 |     |      * @dev The `admin` of the proxy is invalid.
  46 |     |      */
  47 |     |     error ERC1967InvalidAdmin(address admin);
  48 |     | 
  49 |     |     /**
  50 |     |      * @dev The `beacon` of the proxy is invalid.
  51 |     |      */
  52 |     |     error ERC1967InvalidBeacon(address beacon);
  53 |     | 
  54 |     |     /**
  55 |     |      * @dev An upgrade function sees `msg.value > 0` that may be lost.
  56 |     |      */
  57 |     |     error ERC1967NonPayable();
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev Returns the current implementation address.
  61 |     |      */
  62 |     |     function getImplementation() internal view returns (address) {
  63 |     |         return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;
  64 |     |     }
  65 |     | 
  66 |     |     /**
  67 |     |      * @dev Stores a new address in the EIP1967 implementation slot.
  68 |     |      */
  69 |     |     function _setImplementation(address newImplementation) private {
  70 |     |         if (newImplementation.code.length == 0) {
  71 |     |             revert ERC1967InvalidImplementation(newImplementation);
  72 |     |         }
  73 |     |         StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;
  74 |     |     }
  75 |     | 
  76 |     |     /**
  77 |     |      * @dev Performs implementation upgrade with additional setup call if data is nonempty.
  78 |     |      * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected
  79 |     |      * to avoid stuck value in the contract.
  80 |     |      *
  81 |     |      * Emits an {IERC1967-Upgraded} event.
  82 |     |      */
  83 |     |     function upgradeToAndCall(address newImplementation, bytes memory data) internal {
  84 |     |         _setImplementation(newImplementation);
  85 |     |         emit Upgraded(newImplementation);
  86 |     | 
  87 |     |         if (data.length > 0) {
  88 |     |             Address.functionDelegateCall(newImplementation, data);
  89 |     |         } else {
  90 |     |             _checkNonPayable();
  91 |     |         }
  92 |     |     }
  93 |     | 
  94 |     |     /**
  95 |     |      * @dev Storage slot with the admin of the contract.
  96 |     |      * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1.
  97 |     |      */
  98 |     |     // solhint-disable-next-line private-vars-leading-underscore
  99 |     |     bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;
 100 |     | 
 101 |     |     /**
 102 |     |      * @dev Returns the current admin.
 103 |     |      *
 104 |     |      * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using
 105 |     |      * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.
 106 |     |      * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`
 107 |     |      */
 108 |     |     function getAdmin() internal view returns (address) {
 109 |     |         return StorageSlot.getAddressSlot(ADMIN_SLOT).value;
 110 |     |     }
 111 |     | 
 112 |     |     /**
 113 |     |      * @dev Stores a new address in the EIP1967 admin slot.
 114 |     |      */
 115 |     |     function _setAdmin(address newAdmin) private {
 116 |     |         if (newAdmin == address(0)) {
 117 |     |             revert ERC1967InvalidAdmin(address(0));
 118 |     |         }
 119 |     |         StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;
 120 |     |     }
 121 |     | 
 122 |     |     /**
 123 |     |      * @dev Changes the admin of the proxy.
 124 |     |      *
 125 |     |      * Emits an {IERC1967-AdminChanged} event.
 126 |     |      */
 127 |     |     function changeAdmin(address newAdmin) internal {
 128 |     |         emit AdminChanged(getAdmin(), newAdmin);
 129 |     |         _setAdmin(newAdmin);
 130 |     |     }
 131 |     | 
 132 |     |     /**
 133 |     |      * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.
 134 |     |      * This is the keccak-256 hash of "eip1967.proxy.beacon" subtracted by 1.
 135 |     |      */
 136 |     |     // solhint-disable-next-line private-vars-leading-underscore
 137 |     |     bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;
 138 |     | 
 139 |     |     /**
 140 |     |      * @dev Returns the current beacon.
 141 |     |      */
 142 |     |     function getBeacon() internal view returns (address) {
 143 |     |         return StorageSlot.getAddressSlot(BEACON_SLOT).value;
 144 |     |     }
 145 |     | 
 146 |     |     /**
 147 |     |      * @dev Stores a new beacon in the EIP1967 beacon slot.
 148 |     |      */
 149 |     |     function _setBeacon(address newBeacon) private {
 150 |     |         if (newBeacon.code.length == 0) {
 151 |     |             revert ERC1967InvalidBeacon(newBeacon);
 152 |     |         }
 153 |     | 
 154 |     |         StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;
 155 |     | 
 156 |     |         address beaconImplementation = IBeacon(newBeacon).implementation();
 157 |     |         if (beaconImplementation.code.length == 0) {
 158 |     |             revert ERC1967InvalidImplementation(beaconImplementation);
 159 |     |         }
 160 |     |     }
 161 |     | 
 162 |     |     /**
 163 |     |      * @dev Change the beacon and trigger a setup call if data is nonempty.
 164 |     |      * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected
 165 |     |      * to avoid stuck value in the contract.
 166 |     |      *
 167 |     |      * Emits an {IERC1967-BeaconUpgraded} event.
 168 |     |      *
 169 |     |      * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since
 170 |     |      * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for
 171 |     |      * efficiency.
 172 |     |      */
 173 |     |     function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {
 174 |     |         _setBeacon(newBeacon);
 175 |     |         emit BeaconUpgraded(newBeacon);
 176 |     | 
 177 |     |         if (data.length > 0) {
 178 |     |             Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);
 179 |     |         } else {
 180 |     |             _checkNonPayable();
 181 |     |         }
 182 |     |     }
 183 |     | 
 184 |     |     /**
 185 |     |      * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract
 186 |     |      * if an upgrade doesn't perform an initialization call.
 187 |     |      */
 188 |     |     function _checkNonPayable() private {
 189 |     |         if (msg.value > 0) {
 190 |     |             revert ERC1967NonPayable();
 191 |     |         }
 192 |     |     }
 193 |     | }
 194 |     | 

/code/lib/openzeppelin-contracts/contracts/proxy/beacon/IBeacon.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/IBeacon.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev This is the interface that {BeaconProxy} expects of its beacon.
  8 |     |  */
  9 |     | interface IBeacon {
 10 |     |     /**
 11 |     |      * @dev Must return an address that can be used as a delegate call target.
 12 |     |      *
 13 |     |      * {UpgradeableBeacon} will check that this address is a contract.
 14 |     |      */
 15 |     |     function implementation() external view returns (address);
 16 |     | }
 17 |     | 

/code/lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 standard as defined in the EIP.
  8 |     |  */
  9 |     | interface IERC20 {
 10 |     |     /**
 11 |     |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
 12 |     |      * another (`to`).
 13 |     |      *
 14 |     |      * Note that `value` may be zero.
 15 |     |      */
 16 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
 20 |     |      * a call to {approve}. `value` is the new allowance.
 21 |     |      */
 22 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the value of tokens in existence.
 26 |     |      */
 27 |     |     function totalSupply() external view returns (uint256);
 28 |     | 
 29 |     |     /**
 30 |     |      * @dev Returns the value of tokens owned by `account`.
 31 |     |      */
 32 |     |     function balanceOf(address account) external view returns (uint256);
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Moves a `value` amount of tokens from the caller's account to `to`.
 36 |     |      *
 37 |     |      * Returns a boolean value indicating whether the operation succeeded.
 38 |     |      *
 39 |     |      * Emits a {Transfer} event.
 40 |     |      */
 41 |     |     function transfer(address to, uint256 value) external returns (bool);
 42 |     | 
 43 |     |     /**
 44 |     |      * @dev Returns the remaining number of tokens that `spender` will be
 45 |     |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
 46 |     |      * zero by default.
 47 |     |      *
 48 |     |      * This value changes when {approve} or {transferFrom} are called.
 49 |     |      */
 50 |     |     function allowance(address owner, address spender) external view returns (uint256);
 51 |     | 
 52 |     |     /**
 53 |     |      * @dev Sets a `value` amount of tokens as the allowance of `spender` over the
 54 |     |      * caller's tokens.
 55 |     |      *
 56 |     |      * Returns a boolean value indicating whether the operation succeeded.
 57 |     |      *
 58 |     |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
 59 |     |      * that someone may use both the old and the new allowance by unfortunate
 60 |     |      * transaction ordering. One possible solution to mitigate this race
 61 |     |      * condition is to first reduce the spender's allowance to 0 and set the
 62 |     |      * desired value afterwards:
 63 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 64 |     |      *
 65 |     |      * Emits an {Approval} event.
 66 |     |      */
 67 |     |     function approve(address spender, uint256 value) external returns (bool);
 68 |     | 
 69 |     |     /**
 70 |     |      * @dev Moves a `value` amount of tokens from `from` to `to` using the
 71 |     |      * allowance mechanism. `value` is then deducted from the caller's
 72 |     |      * allowance.
 73 |     |      *
 74 |     |      * Returns a boolean value indicating whether the operation succeeded.
 75 |     |      *
 76 |     |      * Emits a {Transfer} event.
 77 |     |      */
 78 |     |     function transferFrom(address from, address to, uint256 value) external returns (bool);
 79 |     | }
 80 |     | 

/code/lib/openzeppelin-contracts/contracts/utils/Address.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev Collection of functions related to the address type
   8 |     |  */
   9 |     | library Address {
  10 |     |     /**
  11 |     |      * @dev The ETH balance of the account is not enough to perform the operation.
  12 |     |      */
  13 |     |     error AddressInsufficientBalance(address account);
  14 |     | 
  15 |     |     /**
  16 |     |      * @dev There's no code at `target` (it is not a contract).
  17 |     |      */
  18 |     |     error AddressEmptyCode(address target);
  19 |     | 
  20 |     |     /**
  21 |     |      * @dev A call to an address target failed. The target may have reverted.
  22 |     |      */
  23 |     |     error FailedInnerCall();
  24 |     | 
  25 |     |     /**
  26 |     |      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
  27 |     |      * `recipient`, forwarding all available gas and reverting on errors.
  28 |     |      *
  29 |     |      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
  30 |     |      * of certain opcodes, possibly making contracts go over the 2300 gas limit
  31 |     |      * imposed by `transfer`, making them unable to receive funds via
  32 |     |      * `transfer`. {sendValue} removes this limitation.
  33 |     |      *
  34 |     |      * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].
  35 |     |      *
  36 |     |      * IMPORTANT: because control is transferred to `recipient`, care must be
  37 |     |      * taken to not create reentrancy vulnerabilities. Consider using
  38 |     |      * {ReentrancyGuard} or the
  39 |     |      * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
  40 |     |      */
  41 |     |     function sendValue(address payable recipient, uint256 amount) internal {
  42 |     |         if (address(this).balance < amount) {
  43 |     |             revert AddressInsufficientBalance(address(this));
  44 |     |         }
  45 |     | 
  46 |     |         (bool success, ) = recipient.call{value: amount}("");
  47 |     |         if (!success) {
  48 |     |             revert FailedInnerCall();
  49 |     |         }
  50 |     |     }
  51 |     | 
  52 |     |     /**
  53 |     |      * @dev Performs a Solidity function call using a low level `call`. A
  54 |     |      * plain `call` is an unsafe replacement for a function call: use this
  55 |     |      * function instead.
  56 |     |      *
  57 |     |      * If `target` reverts with a revert reason or custom error, it is bubbled
  58 |     |      * up by this function (like regular Solidity function calls). However, if
  59 |     |      * the call reverted with no returned reason, this function reverts with a
  60 |     |      * {FailedInnerCall} error.
  61 |     |      *
  62 |     |      * Returns the raw returned data. To convert to the expected return value,
  63 |     |      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
  64 |     |      *
  65 |     |      * Requirements:
  66 |     |      *
  67 |     |      * - `target` must be a contract.
  68 |     |      * - calling `target` with `data` must not revert.
  69 |     |      */
  70 |     |     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
  71 |     |         return functionCallWithValue(target, data, 0);
  72 |     |     }
  73 |     | 
  74 |     |     /**
  75 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
  76 |     |      * but also transferring `value` wei to `target`.
  77 |     |      *
  78 |     |      * Requirements:
  79 |     |      *
  80 |     |      * - the calling contract must have an ETH balance of at least `value`.
  81 |     |      * - the called Solidity function must be `payable`.
  82 |     |      */
  83 |     |     function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
  84 |     |         if (address(this).balance < value) {
  85 |     |             revert AddressInsufficientBalance(address(this));
  86 |     |         }
  87 |     |         (bool success, bytes memory returndata) = target.call{value: value}(data);
  88 |     |         return verifyCallResultFromTarget(target, success, returndata);
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
  93 |     |      * but performing a static call.
  94 |     |      */
  95 |     |     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
  96 |     |         (bool success, bytes memory returndata) = target.staticcall(data);
  97 |     |         return verifyCallResultFromTarget(target, success, returndata);
  98 |     |     }
  99 |     | 
 100 |     |     /**
 101 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 102 |     |      * but performing a delegate call.
 103 |     |      */
 104 |     |     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
 105 |     |         (bool success, bytes memory returndata) = target.delegatecall(data);
 106 |     |         return verifyCallResultFromTarget(target, success, returndata);
 107 |     |     }
 108 |     | 
 109 |     |     /**
 110 |     |      * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target
 111 |     |      * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an
 112 |     |      * unsuccessful call.
 113 |     |      */
 114 |     |     function verifyCallResultFromTarget(
 115 |     |         address target,
 116 |     |         bool success,
 117 |     |         bytes memory returndata
 118 |     |     ) internal view returns (bytes memory) {
 119 |     |         if (!success) {
 120 |     |             _revert(returndata);
 121 |     |         } else {
 122 |     |             // only check if target is a contract if the call was successful and the return data is empty
 123 |     |             // otherwise we already know that it was a contract
 124 |     |             if (returndata.length == 0 && target.code.length == 0) {
 125 |     |                 revert AddressEmptyCode(target);
 126 |     |             }
 127 |     |             return returndata;
 128 |     |         }
 129 |     |     }
 130 |     | 
 131 |     |     /**
 132 |     |      * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the
 133 |     |      * revert reason or with a default {FailedInnerCall} error.
 134 |     |      */
 135 |     |     function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {
 136 |     |         if (!success) {
 137 |     |             _revert(returndata);
 138 |     |         } else {
 139 |     |             return returndata;
 140 |     |         }
 141 |     |     }
 142 |     | 
 143 |     |     /**
 144 |     |      * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.
 145 |     |      */
 146 |     |     function _revert(bytes memory returndata) private pure {
 147 |     |         // Look for revert reason and bubble it up if present
 148 |     |         if (returndata.length > 0) {
 149 |     |             // The easiest way to bubble the revert reason is using memory via assembly
 150 |     |             /// @solidity memory-safe-assembly
 151 |     |             assembly {
 152 |     |                 let returndata_size := mload(returndata)
 153 |     |                 revert(add(32, returndata), returndata_size)
 154 |     |             }
 155 |     |         } else {
 156 |     |             revert FailedInnerCall();
 157 |     |         }
 158 |     |     }
 159 |     | }
 160 |     | 

/code/lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)
   3 |     | // This file was procedurally generated from scripts/generate/templates/StorageSlot.js.
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | /**
   8 |     |  * @dev Library for reading and writing primitive types to specific storage slots.
   9 |     |  *
  10 |     |  * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.
  11 |     |  * This library helps with reading and writing to such slots without the need for inline assembly.
  12 |     |  *
  13 |     |  * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.
  14 |     |  *
  15 |     |  * Example usage to set ERC1967 implementation slot:
  16 |     |  * ```solidity
  17 |     |  * contract ERC1967 {
  18 |     |  *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
  19 |     |  *
  20 |     |  *     function _getImplementation() internal view returns (address) {
  21 |     |  *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;
  22 |     |  *     }
  23 |     |  *
  24 |     |  *     function _setImplementation(address newImplementation) internal {
  25 |     |  *         require(newImplementation.code.length > 0);
  26 |     |  *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;
  27 |     |  *     }
  28 |     |  * }
  29 |     |  * ```
  30 |     |  */
  31 |     | library StorageSlot {
  32 |     |     struct AddressSlot {
  33 |     |         address value;
  34 |     |     }
  35 |     | 
  36 |     |     struct BooleanSlot {
  37 |     |         bool value;
  38 |     |     }
  39 |     | 
  40 |     |     struct Bytes32Slot {
  41 |     |         bytes32 value;
  42 |     |     }
  43 |     | 
  44 |     |     struct Uint256Slot {
  45 |     |         uint256 value;
  46 |     |     }
  47 |     | 
  48 |     |     struct StringSlot {
  49 |     |         string value;
  50 |     |     }
  51 |     | 
  52 |     |     struct BytesSlot {
  53 |     |         bytes value;
  54 |     |     }
  55 |     | 
  56 |     |     /**
  57 |     |      * @dev Returns an `AddressSlot` with member `value` located at `slot`.
  58 |     |      */
  59 |     |     function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {
  60 |     |         /// @solidity memory-safe-assembly
  61 |     |         assembly {
  62 |     |             r.slot := slot
  63 |     |         }
  64 |     |     }
  65 |     | 
  66 |     |     /**
  67 |     |      * @dev Returns an `BooleanSlot` with member `value` located at `slot`.
  68 |     |      */
  69 |     |     function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {
  70 |     |         /// @solidity memory-safe-assembly
  71 |     |         assembly {
  72 |     |             r.slot := slot
  73 |     |         }
  74 |     |     }
  75 |     | 
  76 |     |     /**
  77 |     |      * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.
  78 |     |      */
  79 |     |     function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {
  80 |     |         /// @solidity memory-safe-assembly
  81 |     |         assembly {
  82 |     |             r.slot := slot
  83 |     |         }
  84 |     |     }
  85 |     | 
  86 |     |     /**
  87 |     |      * @dev Returns an `Uint256Slot` with member `value` located at `slot`.
  88 |     |      */
  89 |     |     function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {
  90 |     |         /// @solidity memory-safe-assembly
  91 |     |         assembly {
  92 |     |             r.slot := slot
  93 |     |         }
  94 |     |     }
  95 |     | 
  96 |     |     /**
  97 |     |      * @dev Returns an `StringSlot` with member `value` located at `slot`.
  98 |     |      */
  99 |     |     function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {
 100 |     |         /// @solidity memory-safe-assembly
 101 |     |         assembly {
 102 |     |             r.slot := slot
 103 |     |         }
 104 |     |     }
 105 |     | 
 106 |     |     /**
 107 |     |      * @dev Returns an `StringSlot` representation of the string storage pointer `store`.
 108 |     |      */
 109 |     |     function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {
 110 |     |         /// @solidity memory-safe-assembly
 111 |     |         assembly {
 112 |     |             r.slot := store.slot
 113 |     |         }
 114 |     |     }
 115 |     | 
 116 |     |     /**
 117 |     |      * @dev Returns an `BytesSlot` with member `value` located at `slot`.
 118 |     |      */
 119 |     |     function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {
 120 |     |         /// @solidity memory-safe-assembly
 121 |     |         assembly {
 122 |     |             r.slot := slot
 123 |     |         }
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.
 128 |     |      */
 129 |     |     function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {
 130 |     |         /// @solidity memory-safe-assembly
 131 |     |         assembly {
 132 |     |             r.slot := store.slot
 133 |     |         }
 134 |     |     }
 135 |     | }
 136 |     | 

/code/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC165 standard, as defined in the
  8 |     |  * https://eips.ethereum.org/EIPS/eip-165[EIP].
  9 |     |  *
 10 |     |  * Implementers can declare support of contract interfaces, which can then be
 11 |     |  * queried by others ({ERC165Checker}).
 12 |     |  *
 13 |     |  * For an implementation, see {ERC165}.
 14 |     |  */
 15 |     | interface IERC165 {
 16 |     |     /**
 17 |     |      * @dev Returns true if this contract implements the interface defined by
 18 |     |      * `interfaceId`. See the corresponding
 19 |     |      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
 20 |     |      * to learn more about how these ids are created.
 21 |     |      *
 22 |     |      * This function call must use less than 30 000 gas.
 23 |     |      */
 24 |     |     function supportsInterface(bytes4 interfaceId) external view returns (bool);
 25 |     | }
 26 |     | 

/code/lib/openzeppelin-contracts/contracts/utils/math/Math.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev Standard math utilities missing in the Solidity language.
   8 |     |  */
   9 |     | library Math {
  10 |     |     /**
  11 |     |      * @dev Muldiv operation overflow.
  12 |     |      */
  13 |     |     error MathOverflowedMulDiv();
  14 |     | 
  15 |     |     enum Rounding {
  16 |     |         Floor, // Toward negative infinity
  17 |     |         Ceil, // Toward positive infinity
  18 |     |         Trunc, // Toward zero
  19 |     |         Expand // Away from zero
  20 |     |     }
  21 |     | 
  22 |     |     /**
  23 |     |      * @dev Returns the addition of two unsigned integers, with an overflow flag.
  24 |     |      */
  25 |     |     function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
  26 |     |         unchecked {
  27 |     |             uint256 c = a + b;
  28 |     |             if (c < a) return (false, 0);
  29 |     |             return (true, c);
  30 |     |         }
  31 |     |     }
  32 |     | 
  33 |     |     /**
  34 |     |      * @dev Returns the subtraction of two unsigned integers, with an overflow flag.
  35 |     |      */
  36 |     |     function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
  37 |     |         unchecked {
  38 |     |             if (b > a) return (false, 0);
  39 |     |             return (true, a - b);
  40 |     |         }
  41 |     |     }
  42 |     | 
  43 |     |     /**
  44 |     |      * @dev Returns the multiplication of two unsigned integers, with an overflow flag.
  45 |     |      */
  46 |     |     function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
  47 |     |         unchecked {
  48 |     |             // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
  49 |     |             // benefit is lost if 'b' is also tested.
  50 |     |             // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
  51 |     |             if (a == 0) return (true, 0);
  52 |     |             uint256 c = a * b;
  53 |     |             if (c / a != b) return (false, 0);
  54 |     |             return (true, c);
  55 |     |         }
  56 |     |     }
  57 |     | 
  58 |     |     /**
  59 |     |      * @dev Returns the division of two unsigned integers, with a division by zero flag.
  60 |     |      */
  61 |     |     function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
  62 |     |         unchecked {
  63 |     |             if (b == 0) return (false, 0);
  64 |     |             return (true, a / b);
  65 |     |         }
  66 |     |     }
  67 |     | 
  68 |     |     /**
  69 |     |      * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.
  70 |     |      */
  71 |     |     function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
  72 |     |         unchecked {
  73 |     |             if (b == 0) return (false, 0);
  74 |     |             return (true, a % b);
  75 |     |         }
  76 |     |     }
  77 |     | 
  78 |     |     /**
  79 |     |      * @dev Returns the largest of two numbers.
  80 |     |      */
  81 |     |     function max(uint256 a, uint256 b) internal pure returns (uint256) {
  82 |     |         return a > b ? a : b;
  83 |     |     }
  84 |     | 
  85 |     |     /**
  86 |     |      * @dev Returns the smallest of two numbers.
  87 |     |      */
  88 |     |     function min(uint256 a, uint256 b) internal pure returns (uint256) {
  89 | *   |         return a < b ? a : b;
  90 |     |     }
  91 |     | 
  92 |     |     /**
  93 |     |      * @dev Returns the average of two numbers. The result is rounded towards
  94 |     |      * zero.
  95 |     |      */
  96 |     |     function average(uint256 a, uint256 b) internal pure returns (uint256) {
  97 |     |         // (a + b) / 2 can overflow.
  98 |     |         return (a & b) + (a ^ b) / 2;
  99 |     |     }
 100 |     | 
 101 |     |     /**
 102 |     |      * @dev Returns the ceiling of the division of two numbers.
 103 |     |      *
 104 |     |      * This differs from standard division with `/` in that it rounds towards infinity instead
 105 |     |      * of rounding towards zero.
 106 |     |      */
 107 |     |     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
 108 |     |         if (b == 0) {
 109 |     |             // Guarantee the same behavior as in a regular Solidity division.
 110 |     |             return a / b;
 111 |     |         }
 112 |     | 
 113 |     |         // (a + b - 1) / b can overflow on addition, so we distribute.
 114 |     |         return a == 0 ? 0 : (a - 1) / b + 1;
 115 |     |     }
 116 |     | 
 117 |     |     /**
 118 |     |      * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or
 119 |     |      * denominator == 0.
 120 |     |      * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by
 121 |     |      * Uniswap Labs also under MIT license.
 122 |     |      */
 123 | *   |     function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {
 124 |     |         unchecked {
 125 |     |             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
 126 |     |             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
 127 |     |             // variables such that product = prod1 * 2^256 + prod0.
 128 |     |             uint256 prod0 = x * y; // Least significant 256 bits of the product
 129 |     |             uint256 prod1; // Most significant 256 bits of the product
 130 | *   |             assembly {
 131 |     |                 let mm := mulmod(x, y, not(0))
 132 |     |                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
 133 |     |             }
 134 |     | 
 135 |     |             // Handle non-overflow cases, 256 by 256 division.
 136 | *   |             if (prod1 == 0) {
 137 |     |                 // Solidity will revert if denominator == 0, unlike the div opcode on its own.
 138 |     |                 // The surrounding unchecked block does not change this fact.
 139 |     |                 // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.
 140 | *   |                 return prod0 / denominator;
 141 |     |             }
 142 |     | 
 143 |     |             // Make sure the result is less than 2^256. Also prevents denominator == 0.
 144 |     |             if (denominator <= prod1) {
 145 |     |                 revert MathOverflowedMulDiv();
 146 |     |             }
 147 |     | 
 148 |     |             ///////////////////////////////////////////////
 149 |     |             // 512 by 256 division.
 150 |     |             ///////////////////////////////////////////////
 151 |     | 
 152 |     |             // Make division exact by subtracting the remainder from [prod1 prod0].
 153 |     |             uint256 remainder;
 154 |     |             assembly {
 155 |     |                 // Compute remainder using mulmod.
 156 |     |                 remainder := mulmod(x, y, denominator)
 157 |     | 
 158 |     |                 // Subtract 256 bit number from 512 bit number.
 159 |     |                 prod1 := sub(prod1, gt(remainder, prod0))
 160 |     |                 prod0 := sub(prod0, remainder)
 161 |     |             }
 162 |     | 
 163 |     |             // Factor powers of two out of denominator and compute largest power of two divisor of denominator.
 164 |     |             // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.
 165 |     | 
 166 |     |             uint256 twos = denominator & (0 - denominator);
 167 |     |             assembly {
 168 |     |                 // Divide denominator by twos.
 169 |     |                 denominator := div(denominator, twos)
 170 |     | 
 171 |     |                 // Divide [prod1 prod0] by twos.
 172 |     |                 prod0 := div(prod0, twos)
 173 |     | 
 174 |     |                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
 175 |     |                 twos := add(div(sub(0, twos), twos), 1)
 176 |     |             }
 177 |     | 
 178 |     |             // Shift in bits from prod1 into prod0.
 179 |     |             prod0 |= prod1 * twos;
 180 |     | 
 181 |     |             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
 182 |     |             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
 183 |     |             // four bits. That is, denominator * inv = 1 mod 2^4.
 184 |     |             uint256 inverse = (3 * denominator) ^ 2;
 185 |     | 
 186 |     |             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also
 187 |     |             // works in modular arithmetic, doubling the correct bits in each step.
 188 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^8
 189 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^16
 190 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^32
 191 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^64
 192 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^128
 193 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^256
 194 |     | 
 195 |     |             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
 196 |     |             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
 197 |     |             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
 198 |     |             // is no longer required.
 199 |     |             result = prod0 * inverse;
 200 |     |             return result;
 201 |     |         }
 202 |     |     }
 203 |     | 
 204 |     |     /**
 205 |     |      * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.
 206 |     |      */
 207 |     |     function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {
 208 |     |         uint256 result = mulDiv(x, y, denominator);
 209 |     |         if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {
 210 |     |             result += 1;
 211 |     |         }
 212 |     |         return result;
 213 |     |     }
 214 |     | 
 215 |     |     /**
 216 |     |      * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded
 217 |     |      * towards zero.
 218 |     |      *
 219 |     |      * Inspired by Henry S. Warren, Jr.'s "Hacker's Delight" (Chapter 11).
 220 |     |      */
 221 |     |     function sqrt(uint256 a) internal pure returns (uint256) {
 222 |     |         if (a == 0) {
 223 |     |             return 0;
 224 |     |         }
 225 |     | 
 226 |     |         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
 227 |     |         //
 228 |     |         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
 229 |     |         // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
 230 |     |         //
 231 |     |         // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
 232 |     |         // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
 233 |     |         // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
 234 |     |         //
 235 |     |         // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
 236 |     |         uint256 result = 1 << (log2(a) >> 1);
 237 |     | 
 238 |     |         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
 239 |     |         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
 240 |     |         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
 241 |     |         // into the expected uint128 result.
 242 |     |         unchecked {
 243 |     |             result = (result + a / result) >> 1;
 244 |     |             result = (result + a / result) >> 1;
 245 |     |             result = (result + a / result) >> 1;
 246 |     |             result = (result + a / result) >> 1;
 247 |     |             result = (result + a / result) >> 1;
 248 |     |             result = (result + a / result) >> 1;
 249 |     |             result = (result + a / result) >> 1;
 250 |     |             return min(result, a / result);
 251 |     |         }
 252 |     |     }
 253 |     | 
 254 |     |     /**
 255 |     |      * @notice Calculates sqrt(a), following the selected rounding direction.
 256 |     |      */
 257 |     |     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
 258 |     |         unchecked {
 259 |     |             uint256 result = sqrt(a);
 260 |     |             return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);
 261 |     |         }
 262 |     |     }
 263 |     | 
 264 |     |     /**
 265 |     |      * @dev Return the log in base 2 of a positive value rounded towards zero.
 266 |     |      * Returns 0 if given 0.
 267 |     |      */
 268 |     |     function log2(uint256 value) internal pure returns (uint256) {
 269 |     |         uint256 result = 0;
 270 |     |         unchecked {
 271 |     |             if (value >> 128 > 0) {
 272 |     |                 value >>= 128;
 273 |     |                 result += 128;
 274 |     |             }
 275 |     |             if (value >> 64 > 0) {
 276 |     |                 value >>= 64;
 277 |     |                 result += 64;
 278 |     |             }
 279 |     |             if (value >> 32 > 0) {
 280 |     |                 value >>= 32;
 281 |     |                 result += 32;
 282 |     |             }
 283 |     |             if (value >> 16 > 0) {
 284 |     |                 value >>= 16;
 285 |     |                 result += 16;
 286 |     |             }
 287 |     |             if (value >> 8 > 0) {
 288 |     |                 value >>= 8;
 289 |     |                 result += 8;
 290 |     |             }
 291 |     |             if (value >> 4 > 0) {
 292 |     |                 value >>= 4;
 293 |     |                 result += 4;
 294 |     |             }
 295 |     |             if (value >> 2 > 0) {
 296 |     |                 value >>= 2;
 297 |     |                 result += 2;
 298 |     |             }
 299 |     |             if (value >> 1 > 0) {
 300 |     |                 result += 1;
 301 |     |             }
 302 |     |         }
 303 |     |         return result;
 304 |     |     }
 305 |     | 
 306 |     |     /**
 307 |     |      * @dev Return the log in base 2, following the selected rounding direction, of a positive value.
 308 |     |      * Returns 0 if given 0.
 309 |     |      */
 310 |     |     function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
 311 |     |         unchecked {
 312 |     |             uint256 result = log2(value);
 313 |     |             return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);
 314 |     |         }
 315 |     |     }
 316 |     | 
 317 |     |     /**
 318 |     |      * @dev Return the log in base 10 of a positive value rounded towards zero.
 319 |     |      * Returns 0 if given 0.
 320 |     |      */
 321 |     |     function log10(uint256 value) internal pure returns (uint256) {
 322 |     |         uint256 result = 0;
 323 |     |         unchecked {
 324 |     |             if (value >= 10 ** 64) {
 325 |     |                 value /= 10 ** 64;
 326 |     |                 result += 64;
 327 |     |             }
 328 |     |             if (value >= 10 ** 32) {
 329 |     |                 value /= 10 ** 32;
 330 |     |                 result += 32;
 331 |     |             }
 332 |     |             if (value >= 10 ** 16) {
 333 |     |                 value /= 10 ** 16;
 334 |     |                 result += 16;
 335 |     |             }
 336 |     |             if (value >= 10 ** 8) {
 337 |     |                 value /= 10 ** 8;
 338 |     |                 result += 8;
 339 |     |             }
 340 |     |             if (value >= 10 ** 4) {
 341 |     |                 value /= 10 ** 4;
 342 |     |                 result += 4;
 343 |     |             }
 344 |     |             if (value >= 10 ** 2) {
 345 |     |                 value /= 10 ** 2;
 346 |     |                 result += 2;
 347 |     |             }
 348 |     |             if (value >= 10 ** 1) {
 349 |     |                 result += 1;
 350 |     |             }
 351 |     |         }
 352 |     |         return result;
 353 |     |     }
 354 |     | 
 355 |     |     /**
 356 |     |      * @dev Return the log in base 10, following the selected rounding direction, of a positive value.
 357 |     |      * Returns 0 if given 0.
 358 |     |      */
 359 |     |     function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
 360 |     |         unchecked {
 361 |     |             uint256 result = log10(value);
 362 |     |             return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);
 363 |     |         }
 364 |     |     }
 365 |     | 
 366 |     |     /**
 367 |     |      * @dev Return the log in base 256 of a positive value rounded towards zero.
 368 |     |      * Returns 0 if given 0.
 369 |     |      *
 370 |     |      * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.
 371 |     |      */
 372 |     |     function log256(uint256 value) internal pure returns (uint256) {
 373 |     |         uint256 result = 0;
 374 |     |         unchecked {
 375 |     |             if (value >> 128 > 0) {
 376 |     |                 value >>= 128;
 377 |     |                 result += 16;
 378 |     |             }
 379 |     |             if (value >> 64 > 0) {
 380 |     |                 value >>= 64;
 381 |     |                 result += 8;
 382 |     |             }
 383 |     |             if (value >> 32 > 0) {
 384 |     |                 value >>= 32;
 385 |     |                 result += 4;
 386 |     |             }
 387 |     |             if (value >> 16 > 0) {
 388 |     |                 value >>= 16;
 389 |     |                 result += 2;
 390 |     |             }
 391 |     |             if (value >> 8 > 0) {
 392 |     |                 result += 1;
 393 |     |             }
 394 |     |         }
 395 |     |         return result;
 396 |     |     }
 397 |     | 
 398 |     |     /**
 399 |     |      * @dev Return the log in base 256, following the selected rounding direction, of a positive value.
 400 |     |      * Returns 0 if given 0.
 401 |     |      */
 402 |     |     function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
 403 |     |         unchecked {
 404 |     |             uint256 result = log256(value);
 405 |     |             return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);
 406 |     |         }
 407 |     |     }
 408 |     | 
 409 |     |     /**
 410 |     |      * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.
 411 |     |      */
 412 |     |     function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {
 413 |     |         return uint8(rounding) % 2 == 1;
 414 |     |     }
 415 |     | }
 416 |     | 

/code/lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol
    1 |     | // SPDX-License-Identifier: MIT
    2 |     | // OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)
    3 |     | // This file was procedurally generated from scripts/generate/templates/SafeCast.js.
    4 |     | 
    5 |     | pragma solidity ^0.8.20;
    6 |     | 
    7 |     | /**
    8 |     |  * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow
    9 |     |  * checks.
   10 |     |  *
   11 |     |  * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can
   12 |     |  * easily result in undesired exploitation or bugs, since developers usually
   13 |     |  * assume that overflows raise errors. `SafeCast` restores this intuition by
   14 |     |  * reverting the transaction when such an operation overflows.
   15 |     |  *
   16 |     |  * Using this library instead of the unchecked operations eliminates an entire
   17 |     |  * class of bugs, so it's recommended to use it always.
   18 |     |  */
   19 |     | library SafeCast {
   20 |     |     /**
   21 |     |      * @dev Value doesn't fit in an uint of `bits` size.
   22 |     |      */
   23 |     |     error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);
   24 |     | 
   25 |     |     /**
   26 |     |      * @dev An int value doesn't fit in an uint of `bits` size.
   27 |     |      */
   28 |     |     error SafeCastOverflowedIntToUint(int256 value);
   29 |     | 
   30 |     |     /**
   31 |     |      * @dev Value doesn't fit in an int of `bits` size.
   32 |     |      */
   33 |     |     error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);
   34 |     | 
   35 |     |     /**
   36 |     |      * @dev An uint value doesn't fit in an int of `bits` size.
   37 |     |      */
   38 |     |     error SafeCastOverflowedUintToInt(uint256 value);
   39 |     | 
   40 |     |     /**
   41 |     |      * @dev Returns the downcasted uint248 from uint256, reverting on
   42 |     |      * overflow (when the input is greater than largest uint248).
   43 |     |      *
   44 |     |      * Counterpart to Solidity's `uint248` operator.
   45 |     |      *
   46 |     |      * Requirements:
   47 |     |      *
   48 |     |      * - input must fit into 248 bits
   49 |     |      */
   50 |     |     function toUint248(uint256 value) internal pure returns (uint248) {
   51 |     |         if (value > type(uint248).max) {
   52 |     |             revert SafeCastOverflowedUintDowncast(248, value);
   53 |     |         }
   54 |     |         return uint248(value);
   55 |     |     }
   56 |     | 
   57 |     |     /**
   58 |     |      * @dev Returns the downcasted uint240 from uint256, reverting on
   59 |     |      * overflow (when the input is greater than largest uint240).
   60 |     |      *
   61 |     |      * Counterpart to Solidity's `uint240` operator.
   62 |     |      *
   63 |     |      * Requirements:
   64 |     |      *
   65 |     |      * - input must fit into 240 bits
   66 |     |      */
   67 |     |     function toUint240(uint256 value) internal pure returns (uint240) {
   68 |     |         if (value > type(uint240).max) {
   69 |     |             revert SafeCastOverflowedUintDowncast(240, value);
   70 |     |         }
   71 |     |         return uint240(value);
   72 |     |     }
   73 |     | 
   74 |     |     /**
   75 |     |      * @dev Returns the downcasted uint232 from uint256, reverting on
   76 |     |      * overflow (when the input is greater than largest uint232).
   77 |     |      *
   78 |     |      * Counterpart to Solidity's `uint232` operator.
   79 |     |      *
   80 |     |      * Requirements:
   81 |     |      *
   82 |     |      * - input must fit into 232 bits
   83 |     |      */
   84 |     |     function toUint232(uint256 value) internal pure returns (uint232) {
   85 |     |         if (value > type(uint232).max) {
   86 |     |             revert SafeCastOverflowedUintDowncast(232, value);
   87 |     |         }
   88 |     |         return uint232(value);
   89 |     |     }
   90 |     | 
   91 |     |     /**
   92 |     |      * @dev Returns the downcasted uint224 from uint256, reverting on
   93 |     |      * overflow (when the input is greater than largest uint224).
   94 |     |      *
   95 |     |      * Counterpart to Solidity's `uint224` operator.
   96 |     |      *
   97 |     |      * Requirements:
   98 |     |      *
   99 |     |      * - input must fit into 224 bits
  100 |     |      */
  101 |     |     function toUint224(uint256 value) internal pure returns (uint224) {
  102 |     |         if (value > type(uint224).max) {
  103 |     |             revert SafeCastOverflowedUintDowncast(224, value);
  104 |     |         }
  105 |     |         return uint224(value);
  106 |     |     }
  107 |     | 
  108 |     |     /**
  109 |     |      * @dev Returns the downcasted uint216 from uint256, reverting on
  110 |     |      * overflow (when the input is greater than largest uint216).
  111 |     |      *
  112 |     |      * Counterpart to Solidity's `uint216` operator.
  113 |     |      *
  114 |     |      * Requirements:
  115 |     |      *
  116 |     |      * - input must fit into 216 bits
  117 |     |      */
  118 | *   |     function toUint216(uint256 value) internal pure returns (uint216) {
  119 | *   |         if (value > type(uint216).max) {
  120 |     |             revert SafeCastOverflowedUintDowncast(216, value);
  121 |     |         }
  122 |     |         return uint216(value);
  123 |     |     }
  124 |     | 
  125 |     |     /**
  126 |     |      * @dev Returns the downcasted uint208 from uint256, reverting on
  127 |     |      * overflow (when the input is greater than largest uint208).
  128 |     |      *
  129 |     |      * Counterpart to Solidity's `uint208` operator.
  130 |     |      *
  131 |     |      * Requirements:
  132 |     |      *
  133 |     |      * - input must fit into 208 bits
  134 |     |      */
  135 |     |     function toUint208(uint256 value) internal pure returns (uint208) {
  136 |     |         if (value > type(uint208).max) {
  137 |     |             revert SafeCastOverflowedUintDowncast(208, value);
  138 |     |         }
  139 |     |         return uint208(value);
  140 |     |     }
  141 |     | 
  142 |     |     /**
  143 |     |      * @dev Returns the downcasted uint200 from uint256, reverting on
  144 |     |      * overflow (when the input is greater than largest uint200).
  145 |     |      *
  146 |     |      * Counterpart to Solidity's `uint200` operator.
  147 |     |      *
  148 |     |      * Requirements:
  149 |     |      *
  150 |     |      * - input must fit into 200 bits
  151 |     |      */
  152 |     |     function toUint200(uint256 value) internal pure returns (uint200) {
  153 |     |         if (value > type(uint200).max) {
  154 |     |             revert SafeCastOverflowedUintDowncast(200, value);
  155 |     |         }
  156 |     |         return uint200(value);
  157 |     |     }
  158 |     | 
  159 |     |     /**
  160 |     |      * @dev Returns the downcasted uint192 from uint256, reverting on
  161 |     |      * overflow (when the input is greater than largest uint192).
  162 |     |      *
  163 |     |      * Counterpart to Solidity's `uint192` operator.
  164 |     |      *
  165 |     |      * Requirements:
  166 |     |      *
  167 |     |      * - input must fit into 192 bits
  168 |     |      */
  169 |     |     function toUint192(uint256 value) internal pure returns (uint192) {
  170 |     |         if (value > type(uint192).max) {
  171 |     |             revert SafeCastOverflowedUintDowncast(192, value);
  172 |     |         }
  173 |     |         return uint192(value);
  174 |     |     }
  175 |     | 
  176 |     |     /**
  177 |     |      * @dev Returns the downcasted uint184 from uint256, reverting on
  178 |     |      * overflow (when the input is greater than largest uint184).
  179 |     |      *
  180 |     |      * Counterpart to Solidity's `uint184` operator.
  181 |     |      *
  182 |     |      * Requirements:
  183 |     |      *
  184 |     |      * - input must fit into 184 bits
  185 |     |      */
  186 |     |     function toUint184(uint256 value) internal pure returns (uint184) {
  187 |     |         if (value > type(uint184).max) {
  188 |     |             revert SafeCastOverflowedUintDowncast(184, value);
  189 |     |         }
  190 |     |         return uint184(value);
  191 |     |     }
  192 |     | 
  193 |     |     /**
  194 |     |      * @dev Returns the downcasted uint176 from uint256, reverting on
  195 |     |      * overflow (when the input is greater than largest uint176).
  196 |     |      *
  197 |     |      * Counterpart to Solidity's `uint176` operator.
  198 |     |      *
  199 |     |      * Requirements:
  200 |     |      *
  201 |     |      * - input must fit into 176 bits
  202 |     |      */
  203 |     |     function toUint176(uint256 value) internal pure returns (uint176) {
  204 |     |         if (value > type(uint176).max) {
  205 |     |             revert SafeCastOverflowedUintDowncast(176, value);
  206 |     |         }
  207 |     |         return uint176(value);
  208 |     |     }
  209 |     | 
  210 |     |     /**
  211 |     |      * @dev Returns the downcasted uint168 from uint256, reverting on
  212 |     |      * overflow (when the input is greater than largest uint168).
  213 |     |      *
  214 |     |      * Counterpart to Solidity's `uint168` operator.
  215 |     |      *
  216 |     |      * Requirements:
  217 |     |      *
  218 |     |      * - input must fit into 168 bits
  219 |     |      */
  220 |     |     function toUint168(uint256 value) internal pure returns (uint168) {
  221 |     |         if (value > type(uint168).max) {
  222 |     |             revert SafeCastOverflowedUintDowncast(168, value);
  223 |     |         }
  224 |     |         return uint168(value);
  225 |     |     }
  226 |     | 
  227 |     |     /**
  228 |     |      * @dev Returns the downcasted uint160 from uint256, reverting on
  229 |     |      * overflow (when the input is greater than largest uint160).
  230 |     |      *
  231 |     |      * Counterpart to Solidity's `uint160` operator.
  232 |     |      *
  233 |     |      * Requirements:
  234 |     |      *
  235 |     |      * - input must fit into 160 bits
  236 |     |      */
  237 |     |     function toUint160(uint256 value) internal pure returns (uint160) {
  238 |     |         if (value > type(uint160).max) {
  239 |     |             revert SafeCastOverflowedUintDowncast(160, value);
  240 |     |         }
  241 |     |         return uint160(value);
  242 |     |     }
  243 |     | 
  244 |     |     /**
  245 |     |      * @dev Returns the downcasted uint152 from uint256, reverting on
  246 |     |      * overflow (when the input is greater than largest uint152).
  247 |     |      *
  248 |     |      * Counterpart to Solidity's `uint152` operator.
  249 |     |      *
  250 |     |      * Requirements:
  251 |     |      *
  252 |     |      * - input must fit into 152 bits
  253 |     |      */
  254 |     |     function toUint152(uint256 value) internal pure returns (uint152) {
  255 |     |         if (value > type(uint152).max) {
  256 |     |             revert SafeCastOverflowedUintDowncast(152, value);
  257 |     |         }
  258 |     |         return uint152(value);
  259 |     |     }
  260 |     | 
  261 |     |     /**
  262 |     |      * @dev Returns the downcasted uint144 from uint256, reverting on
  263 |     |      * overflow (when the input is greater than largest uint144).
  264 |     |      *
  265 |     |      * Counterpart to Solidity's `uint144` operator.
  266 |     |      *
  267 |     |      * Requirements:
  268 |     |      *
  269 |     |      * - input must fit into 144 bits
  270 |     |      */
  271 |     |     function toUint144(uint256 value) internal pure returns (uint144) {
  272 |     |         if (value > type(uint144).max) {
  273 |     |             revert SafeCastOverflowedUintDowncast(144, value);
  274 |     |         }
  275 |     |         return uint144(value);
  276 |     |     }
  277 |     | 
  278 |     |     /**
  279 |     |      * @dev Returns the downcasted uint136 from uint256, reverting on
  280 |     |      * overflow (when the input is greater than largest uint136).
  281 |     |      *
  282 |     |      * Counterpart to Solidity's `uint136` operator.
  283 |     |      *
  284 |     |      * Requirements:
  285 |     |      *
  286 |     |      * - input must fit into 136 bits
  287 |     |      */
  288 |     |     function toUint136(uint256 value) internal pure returns (uint136) {
  289 |     |         if (value > type(uint136).max) {
  290 |     |             revert SafeCastOverflowedUintDowncast(136, value);
  291 |     |         }
  292 |     |         return uint136(value);
  293 |     |     }
  294 |     | 
  295 |     |     /**
  296 |     |      * @dev Returns the downcasted uint128 from uint256, reverting on
  297 |     |      * overflow (when the input is greater than largest uint128).
  298 |     |      *
  299 |     |      * Counterpart to Solidity's `uint128` operator.
  300 |     |      *
  301 |     |      * Requirements:
  302 |     |      *
  303 |     |      * - input must fit into 128 bits
  304 |     |      */
  305 |     |     function toUint128(uint256 value) internal pure returns (uint128) {
  306 |     |         if (value > type(uint128).max) {
  307 |     |             revert SafeCastOverflowedUintDowncast(128, value);
  308 |     |         }
  309 |     |         return uint128(value);
  310 |     |     }
  311 |     | 
  312 |     |     /**
  313 |     |      * @dev Returns the downcasted uint120 from uint256, reverting on
  314 |     |      * overflow (when the input is greater than largest uint120).
  315 |     |      *
  316 |     |      * Counterpart to Solidity's `uint120` operator.
  317 |     |      *
  318 |     |      * Requirements:
  319 |     |      *
  320 |     |      * - input must fit into 120 bits
  321 |     |      */
  322 |     |     function toUint120(uint256 value) internal pure returns (uint120) {
  323 |     |         if (value > type(uint120).max) {
  324 |     |             revert SafeCastOverflowedUintDowncast(120, value);
  325 |     |         }
  326 |     |         return uint120(value);
  327 |     |     }
  328 |     | 
  329 |     |     /**
  330 |     |      * @dev Returns the downcasted uint112 from uint256, reverting on
  331 |     |      * overflow (when the input is greater than largest uint112).
  332 |     |      *
  333 |     |      * Counterpart to Solidity's `uint112` operator.
  334 |     |      *
  335 |     |      * Requirements:
  336 |     |      *
  337 |     |      * - input must fit into 112 bits
  338 |     |      */
  339 |     |     function toUint112(uint256 value) internal pure returns (uint112) {
  340 |     |         if (value > type(uint112).max) {
  341 |     |             revert SafeCastOverflowedUintDowncast(112, value);
  342 |     |         }
  343 |     |         return uint112(value);
  344 |     |     }
  345 |     | 
  346 |     |     /**
  347 |     |      * @dev Returns the downcasted uint104 from uint256, reverting on
  348 |     |      * overflow (when the input is greater than largest uint104).
  349 |     |      *
  350 |     |      * Counterpart to Solidity's `uint104` operator.
  351 |     |      *
  352 |     |      * Requirements:
  353 |     |      *
  354 |     |      * - input must fit into 104 bits
  355 |     |      */
  356 |     |     function toUint104(uint256 value) internal pure returns (uint104) {
  357 |     |         if (value > type(uint104).max) {
  358 |     |             revert SafeCastOverflowedUintDowncast(104, value);
  359 |     |         }
  360 |     |         return uint104(value);
  361 |     |     }
  362 |     | 
  363 |     |     /**
  364 |     |      * @dev Returns the downcasted uint96 from uint256, reverting on
  365 |     |      * overflow (when the input is greater than largest uint96).
  366 |     |      *
  367 |     |      * Counterpart to Solidity's `uint96` operator.
  368 |     |      *
  369 |     |      * Requirements:
  370 |     |      *
  371 |     |      * - input must fit into 96 bits
  372 |     |      */
  373 |     |     function toUint96(uint256 value) internal pure returns (uint96) {
  374 |     |         if (value > type(uint96).max) {
  375 |     |             revert SafeCastOverflowedUintDowncast(96, value);
  376 |     |         }
  377 |     |         return uint96(value);
  378 |     |     }
  379 |     | 
  380 |     |     /**
  381 |     |      * @dev Returns the downcasted uint88 from uint256, reverting on
  382 |     |      * overflow (when the input is greater than largest uint88).
  383 |     |      *
  384 |     |      * Counterpart to Solidity's `uint88` operator.
  385 |     |      *
  386 |     |      * Requirements:
  387 |     |      *
  388 |     |      * - input must fit into 88 bits
  389 |     |      */
  390 |     |     function toUint88(uint256 value) internal pure returns (uint88) {
  391 |     |         if (value > type(uint88).max) {
  392 |     |             revert SafeCastOverflowedUintDowncast(88, value);
  393 |     |         }
  394 |     |         return uint88(value);
  395 |     |     }
  396 |     | 
  397 |     |     /**
  398 |     |      * @dev Returns the downcasted uint80 from uint256, reverting on
  399 |     |      * overflow (when the input is greater than largest uint80).
  400 |     |      *
  401 |     |      * Counterpart to Solidity's `uint80` operator.
  402 |     |      *
  403 |     |      * Requirements:
  404 |     |      *
  405 |     |      * - input must fit into 80 bits
  406 |     |      */
  407 |     |     function toUint80(uint256 value) internal pure returns (uint80) {
  408 |     |         if (value > type(uint80).max) {
  409 |     |             revert SafeCastOverflowedUintDowncast(80, value);
  410 |     |         }
  411 |     |         return uint80(value);
  412 |     |     }
  413 |     | 
  414 |     |     /**
  415 |     |      * @dev Returns the downcasted uint72 from uint256, reverting on
  416 |     |      * overflow (when the input is greater than largest uint72).
  417 |     |      *
  418 |     |      * Counterpart to Solidity's `uint72` operator.
  419 |     |      *
  420 |     |      * Requirements:
  421 |     |      *
  422 |     |      * - input must fit into 72 bits
  423 |     |      */
  424 |     |     function toUint72(uint256 value) internal pure returns (uint72) {
  425 |     |         if (value > type(uint72).max) {
  426 |     |             revert SafeCastOverflowedUintDowncast(72, value);
  427 |     |         }
  428 |     |         return uint72(value);
  429 |     |     }
  430 |     | 
  431 |     |     /**
  432 |     |      * @dev Returns the downcasted uint64 from uint256, reverting on
  433 |     |      * overflow (when the input is greater than largest uint64).
  434 |     |      *
  435 |     |      * Counterpart to Solidity's `uint64` operator.
  436 |     |      *
  437 |     |      * Requirements:
  438 |     |      *
  439 |     |      * - input must fit into 64 bits
  440 |     |      */
  441 |     |     function toUint64(uint256 value) internal pure returns (uint64) {
  442 |     |         if (value > type(uint64).max) {
  443 |     |             revert SafeCastOverflowedUintDowncast(64, value);
  444 |     |         }
  445 |     |         return uint64(value);
  446 |     |     }
  447 |     | 
  448 |     |     /**
  449 |     |      * @dev Returns the downcasted uint56 from uint256, reverting on
  450 |     |      * overflow (when the input is greater than largest uint56).
  451 |     |      *
  452 |     |      * Counterpart to Solidity's `uint56` operator.
  453 |     |      *
  454 |     |      * Requirements:
  455 |     |      *
  456 |     |      * - input must fit into 56 bits
  457 |     |      */
  458 |     |     function toUint56(uint256 value) internal pure returns (uint56) {
  459 |     |         if (value > type(uint56).max) {
  460 |     |             revert SafeCastOverflowedUintDowncast(56, value);
  461 |     |         }
  462 |     |         return uint56(value);
  463 |     |     }
  464 |     | 
  465 |     |     /**
  466 |     |      * @dev Returns the downcasted uint48 from uint256, reverting on
  467 |     |      * overflow (when the input is greater than largest uint48).
  468 |     |      *
  469 |     |      * Counterpart to Solidity's `uint48` operator.
  470 |     |      *
  471 |     |      * Requirements:
  472 |     |      *
  473 |     |      * - input must fit into 48 bits
  474 |     |      */
  475 |     |     function toUint48(uint256 value) internal pure returns (uint48) {
  476 |     |         if (value > type(uint48).max) {
  477 |     |             revert SafeCastOverflowedUintDowncast(48, value);
  478 |     |         }
  479 |     |         return uint48(value);
  480 |     |     }
  481 |     | 
  482 |     |     /**
  483 |     |      * @dev Returns the downcasted uint40 from uint256, reverting on
  484 |     |      * overflow (when the input is greater than largest uint40).
  485 |     |      *
  486 |     |      * Counterpart to Solidity's `uint40` operator.
  487 |     |      *
  488 |     |      * Requirements:
  489 |     |      *
  490 |     |      * - input must fit into 40 bits
  491 |     |      */
  492 |     |     function toUint40(uint256 value) internal pure returns (uint40) {
  493 |     |         if (value > type(uint40).max) {
  494 |     |             revert SafeCastOverflowedUintDowncast(40, value);
  495 |     |         }
  496 |     |         return uint40(value);
  497 |     |     }
  498 |     | 
  499 |     |     /**
  500 |     |      * @dev Returns the downcasted uint32 from uint256, reverting on
  501 |     |      * overflow (when the input is greater than largest uint32).
  502 |     |      *
  503 |     |      * Counterpart to Solidity's `uint32` operator.
  504 |     |      *
  505 |     |      * Requirements:
  506 |     |      *
  507 |     |      * - input must fit into 32 bits
  508 |     |      */
  509 |     |     function toUint32(uint256 value) internal pure returns (uint32) {
  510 |     |         if (value > type(uint32).max) {
  511 |     |             revert SafeCastOverflowedUintDowncast(32, value);
  512 |     |         }
  513 |     |         return uint32(value);
  514 |     |     }
  515 |     | 
  516 |     |     /**
  517 |     |      * @dev Returns the downcasted uint24 from uint256, reverting on
  518 |     |      * overflow (when the input is greater than largest uint24).
  519 |     |      *
  520 |     |      * Counterpart to Solidity's `uint24` operator.
  521 |     |      *
  522 |     |      * Requirements:
  523 |     |      *
  524 |     |      * - input must fit into 24 bits
  525 |     |      */
  526 |     |     function toUint24(uint256 value) internal pure returns (uint24) {
  527 |     |         if (value > type(uint24).max) {
  528 |     |             revert SafeCastOverflowedUintDowncast(24, value);
  529 |     |         }
  530 |     |         return uint24(value);
  531 |     |     }
  532 |     | 
  533 |     |     /**
  534 |     |      * @dev Returns the downcasted uint16 from uint256, reverting on
  535 |     |      * overflow (when the input is greater than largest uint16).
  536 |     |      *
  537 |     |      * Counterpart to Solidity's `uint16` operator.
  538 |     |      *
  539 |     |      * Requirements:
  540 |     |      *
  541 |     |      * - input must fit into 16 bits
  542 |     |      */
  543 |     |     function toUint16(uint256 value) internal pure returns (uint16) {
  544 |     |         if (value > type(uint16).max) {
  545 |     |             revert SafeCastOverflowedUintDowncast(16, value);
  546 |     |         }
  547 |     |         return uint16(value);
  548 |     |     }
  549 |     | 
  550 |     |     /**
  551 |     |      * @dev Returns the downcasted uint8 from uint256, reverting on
  552 |     |      * overflow (when the input is greater than largest uint8).
  553 |     |      *
  554 |     |      * Counterpart to Solidity's `uint8` operator.
  555 |     |      *
  556 |     |      * Requirements:
  557 |     |      *
  558 |     |      * - input must fit into 8 bits
  559 |     |      */
  560 |     |     function toUint8(uint256 value) internal pure returns (uint8) {
  561 |     |         if (value > type(uint8).max) {
  562 |     |             revert SafeCastOverflowedUintDowncast(8, value);
  563 |     |         }
  564 |     |         return uint8(value);
  565 |     |     }
  566 |     | 
  567 |     |     /**
  568 |     |      * @dev Converts a signed int256 into an unsigned uint256.
  569 |     |      *
  570 |     |      * Requirements:
  571 |     |      *
  572 |     |      * - input must be greater than or equal to 0.
  573 |     |      */
  574 |     |     function toUint256(int256 value) internal pure returns (uint256) {
  575 |     |         if (value < 0) {
  576 |     |             revert SafeCastOverflowedIntToUint(value);
  577 |     |         }
  578 |     |         return uint256(value);
  579 |     |     }
  580 |     | 
  581 |     |     /**
  582 |     |      * @dev Returns the downcasted int248 from int256, reverting on
  583 |     |      * overflow (when the input is less than smallest int248 or
  584 |     |      * greater than largest int248).
  585 |     |      *
  586 |     |      * Counterpart to Solidity's `int248` operator.
  587 |     |      *
  588 |     |      * Requirements:
  589 |     |      *
  590 |     |      * - input must fit into 248 bits
  591 |     |      */
  592 |     |     function toInt248(int256 value) internal pure returns (int248 downcasted) {
  593 |     |         downcasted = int248(value);
  594 |     |         if (downcasted != value) {
  595 |     |             revert SafeCastOverflowedIntDowncast(248, value);
  596 |     |         }
  597 |     |     }
  598 |     | 
  599 |     |     /**
  600 |     |      * @dev Returns the downcasted int240 from int256, reverting on
  601 |     |      * overflow (when the input is less than smallest int240 or
  602 |     |      * greater than largest int240).
  603 |     |      *
  604 |     |      * Counterpart to Solidity's `int240` operator.
  605 |     |      *
  606 |     |      * Requirements:
  607 |     |      *
  608 |     |      * - input must fit into 240 bits
  609 |     |      */
  610 |     |     function toInt240(int256 value) internal pure returns (int240 downcasted) {
  611 |     |         downcasted = int240(value);
  612 |     |         if (downcasted != value) {
  613 |     |             revert SafeCastOverflowedIntDowncast(240, value);
  614 |     |         }
  615 |     |     }
  616 |     | 
  617 |     |     /**
  618 |     |      * @dev Returns the downcasted int232 from int256, reverting on
  619 |     |      * overflow (when the input is less than smallest int232 or
  620 |     |      * greater than largest int232).
  621 |     |      *
  622 |     |      * Counterpart to Solidity's `int232` operator.
  623 |     |      *
  624 |     |      * Requirements:
  625 |     |      *
  626 |     |      * - input must fit into 232 bits
  627 |     |      */
  628 |     |     function toInt232(int256 value) internal pure returns (int232 downcasted) {
  629 |     |         downcasted = int232(value);
  630 |     |         if (downcasted != value) {
  631 |     |             revert SafeCastOverflowedIntDowncast(232, value);
  632 |     |         }
  633 |     |     }
  634 |     | 
  635 |     |     /**
  636 |     |      * @dev Returns the downcasted int224 from int256, reverting on
  637 |     |      * overflow (when the input is less than smallest int224 or
  638 |     |      * greater than largest int224).
  639 |     |      *
  640 |     |      * Counterpart to Solidity's `int224` operator.
  641 |     |      *
  642 |     |      * Requirements:
  643 |     |      *
  644 |     |      * - input must fit into 224 bits
  645 |     |      */
  646 |     |     function toInt224(int256 value) internal pure returns (int224 downcasted) {
  647 |     |         downcasted = int224(value);
  648 |     |         if (downcasted != value) {
  649 |     |             revert SafeCastOverflowedIntDowncast(224, value);
  650 |     |         }
  651 |     |     }
  652 |     | 
  653 |     |     /**
  654 |     |      * @dev Returns the downcasted int216 from int256, reverting on
  655 |     |      * overflow (when the input is less than smallest int216 or
  656 |     |      * greater than largest int216).
  657 |     |      *
  658 |     |      * Counterpart to Solidity's `int216` operator.
  659 |     |      *
  660 |     |      * Requirements:
  661 |     |      *
  662 |     |      * - input must fit into 216 bits
  663 |     |      */
  664 |     |     function toInt216(int256 value) internal pure returns (int216 downcasted) {
  665 |     |         downcasted = int216(value);
  666 |     |         if (downcasted != value) {
  667 |     |             revert SafeCastOverflowedIntDowncast(216, value);
  668 |     |         }
  669 |     |     }
  670 |     | 
  671 |     |     /**
  672 |     |      * @dev Returns the downcasted int208 from int256, reverting on
  673 |     |      * overflow (when the input is less than smallest int208 or
  674 |     |      * greater than largest int208).
  675 |     |      *
  676 |     |      * Counterpart to Solidity's `int208` operator.
  677 |     |      *
  678 |     |      * Requirements:
  679 |     |      *
  680 |     |      * - input must fit into 208 bits
  681 |     |      */
  682 |     |     function toInt208(int256 value) internal pure returns (int208 downcasted) {
  683 |     |         downcasted = int208(value);
  684 |     |         if (downcasted != value) {
  685 |     |             revert SafeCastOverflowedIntDowncast(208, value);
  686 |     |         }
  687 |     |     }
  688 |     | 
  689 |     |     /**
  690 |     |      * @dev Returns the downcasted int200 from int256, reverting on
  691 |     |      * overflow (when the input is less than smallest int200 or
  692 |     |      * greater than largest int200).
  693 |     |      *
  694 |     |      * Counterpart to Solidity's `int200` operator.
  695 |     |      *
  696 |     |      * Requirements:
  697 |     |      *
  698 |     |      * - input must fit into 200 bits
  699 |     |      */
  700 |     |     function toInt200(int256 value) internal pure returns (int200 downcasted) {
  701 |     |         downcasted = int200(value);
  702 |     |         if (downcasted != value) {
  703 |     |             revert SafeCastOverflowedIntDowncast(200, value);
  704 |     |         }
  705 |     |     }
  706 |     | 
  707 |     |     /**
  708 |     |      * @dev Returns the downcasted int192 from int256, reverting on
  709 |     |      * overflow (when the input is less than smallest int192 or
  710 |     |      * greater than largest int192).
  711 |     |      *
  712 |     |      * Counterpart to Solidity's `int192` operator.
  713 |     |      *
  714 |     |      * Requirements:
  715 |     |      *
  716 |     |      * - input must fit into 192 bits
  717 |     |      */
  718 |     |     function toInt192(int256 value) internal pure returns (int192 downcasted) {
  719 |     |         downcasted = int192(value);
  720 |     |         if (downcasted != value) {
  721 |     |             revert SafeCastOverflowedIntDowncast(192, value);
  722 |     |         }
  723 |     |     }
  724 |     | 
  725 |     |     /**
  726 |     |      * @dev Returns the downcasted int184 from int256, reverting on
  727 |     |      * overflow (when the input is less than smallest int184 or
  728 |     |      * greater than largest int184).
  729 |     |      *
  730 |     |      * Counterpart to Solidity's `int184` operator.
  731 |     |      *
  732 |     |      * Requirements:
  733 |     |      *
  734 |     |      * - input must fit into 184 bits
  735 |     |      */
  736 |     |     function toInt184(int256 value) internal pure returns (int184 downcasted) {
  737 |     |         downcasted = int184(value);
  738 |     |         if (downcasted != value) {
  739 |     |             revert SafeCastOverflowedIntDowncast(184, value);
  740 |     |         }
  741 |     |     }
  742 |     | 
  743 |     |     /**
  744 |     |      * @dev Returns the downcasted int176 from int256, reverting on
  745 |     |      * overflow (when the input is less than smallest int176 or
  746 |     |      * greater than largest int176).
  747 |     |      *
  748 |     |      * Counterpart to Solidity's `int176` operator.
  749 |     |      *
  750 |     |      * Requirements:
  751 |     |      *
  752 |     |      * - input must fit into 176 bits
  753 |     |      */
  754 |     |     function toInt176(int256 value) internal pure returns (int176 downcasted) {
  755 |     |         downcasted = int176(value);
  756 |     |         if (downcasted != value) {
  757 |     |             revert SafeCastOverflowedIntDowncast(176, value);
  758 |     |         }
  759 |     |     }
  760 |     | 
  761 |     |     /**
  762 |     |      * @dev Returns the downcasted int168 from int256, reverting on
  763 |     |      * overflow (when the input is less than smallest int168 or
  764 |     |      * greater than largest int168).
  765 |     |      *
  766 |     |      * Counterpart to Solidity's `int168` operator.
  767 |     |      *
  768 |     |      * Requirements:
  769 |     |      *
  770 |     |      * - input must fit into 168 bits
  771 |     |      */
  772 |     |     function toInt168(int256 value) internal pure returns (int168 downcasted) {
  773 |     |         downcasted = int168(value);
  774 |     |         if (downcasted != value) {
  775 |     |             revert SafeCastOverflowedIntDowncast(168, value);
  776 |     |         }
  777 |     |     }
  778 |     | 
  779 |     |     /**
  780 |     |      * @dev Returns the downcasted int160 from int256, reverting on
  781 |     |      * overflow (when the input is less than smallest int160 or
  782 |     |      * greater than largest int160).
  783 |     |      *
  784 |     |      * Counterpart to Solidity's `int160` operator.
  785 |     |      *
  786 |     |      * Requirements:
  787 |     |      *
  788 |     |      * - input must fit into 160 bits
  789 |     |      */
  790 |     |     function toInt160(int256 value) internal pure returns (int160 downcasted) {
  791 |     |         downcasted = int160(value);
  792 |     |         if (downcasted != value) {
  793 |     |             revert SafeCastOverflowedIntDowncast(160, value);
  794 |     |         }
  795 |     |     }
  796 |     | 
  797 |     |     /**
  798 |     |      * @dev Returns the downcasted int152 from int256, reverting on
  799 |     |      * overflow (when the input is less than smallest int152 or
  800 |     |      * greater than largest int152).
  801 |     |      *
  802 |     |      * Counterpart to Solidity's `int152` operator.
  803 |     |      *
  804 |     |      * Requirements:
  805 |     |      *
  806 |     |      * - input must fit into 152 bits
  807 |     |      */
  808 |     |     function toInt152(int256 value) internal pure returns (int152 downcasted) {
  809 |     |         downcasted = int152(value);
  810 |     |         if (downcasted != value) {
  811 |     |             revert SafeCastOverflowedIntDowncast(152, value);
  812 |     |         }
  813 |     |     }
  814 |     | 
  815 |     |     /**
  816 |     |      * @dev Returns the downcasted int144 from int256, reverting on
  817 |     |      * overflow (when the input is less than smallest int144 or
  818 |     |      * greater than largest int144).
  819 |     |      *
  820 |     |      * Counterpart to Solidity's `int144` operator.
  821 |     |      *
  822 |     |      * Requirements:
  823 |     |      *
  824 |     |      * - input must fit into 144 bits
  825 |     |      */
  826 |     |     function toInt144(int256 value) internal pure returns (int144 downcasted) {
  827 |     |         downcasted = int144(value);
  828 |     |         if (downcasted != value) {
  829 |     |             revert SafeCastOverflowedIntDowncast(144, value);
  830 |     |         }
  831 |     |     }
  832 |     | 
  833 |     |     /**
  834 |     |      * @dev Returns the downcasted int136 from int256, reverting on
  835 |     |      * overflow (when the input is less than smallest int136 or
  836 |     |      * greater than largest int136).
  837 |     |      *
  838 |     |      * Counterpart to Solidity's `int136` operator.
  839 |     |      *
  840 |     |      * Requirements:
  841 |     |      *
  842 |     |      * - input must fit into 136 bits
  843 |     |      */
  844 |     |     function toInt136(int256 value) internal pure returns (int136 downcasted) {
  845 |     |         downcasted = int136(value);
  846 |     |         if (downcasted != value) {
  847 |     |             revert SafeCastOverflowedIntDowncast(136, value);
  848 |     |         }
  849 |     |     }
  850 |     | 
  851 |     |     /**
  852 |     |      * @dev Returns the downcasted int128 from int256, reverting on
  853 |     |      * overflow (when the input is less than smallest int128 or
  854 |     |      * greater than largest int128).
  855 |     |      *
  856 |     |      * Counterpart to Solidity's `int128` operator.
  857 |     |      *
  858 |     |      * Requirements:
  859 |     |      *
  860 |     |      * - input must fit into 128 bits
  861 |     |      */
  862 |     |     function toInt128(int256 value) internal pure returns (int128 downcasted) {
  863 |     |         downcasted = int128(value);
  864 |     |         if (downcasted != value) {
  865 |     |             revert SafeCastOverflowedIntDowncast(128, value);
  866 |     |         }
  867 |     |     }
  868 |     | 
  869 |     |     /**
  870 |     |      * @dev Returns the downcasted int120 from int256, reverting on
  871 |     |      * overflow (when the input is less than smallest int120 or
  872 |     |      * greater than largest int120).
  873 |     |      *
  874 |     |      * Counterpart to Solidity's `int120` operator.
  875 |     |      *
  876 |     |      * Requirements:
  877 |     |      *
  878 |     |      * - input must fit into 120 bits
  879 |     |      */
  880 |     |     function toInt120(int256 value) internal pure returns (int120 downcasted) {
  881 |     |         downcasted = int120(value);
  882 |     |         if (downcasted != value) {
  883 |     |             revert SafeCastOverflowedIntDowncast(120, value);
  884 |     |         }
  885 |     |     }
  886 |     | 
  887 |     |     /**
  888 |     |      * @dev Returns the downcasted int112 from int256, reverting on
  889 |     |      * overflow (when the input is less than smallest int112 or
  890 |     |      * greater than largest int112).
  891 |     |      *
  892 |     |      * Counterpart to Solidity's `int112` operator.
  893 |     |      *
  894 |     |      * Requirements:
  895 |     |      *
  896 |     |      * - input must fit into 112 bits
  897 |     |      */
  898 |     |     function toInt112(int256 value) internal pure returns (int112 downcasted) {
  899 |     |         downcasted = int112(value);
  900 |     |         if (downcasted != value) {
  901 |     |             revert SafeCastOverflowedIntDowncast(112, value);
  902 |     |         }
  903 |     |     }
  904 |     | 
  905 |     |     /**
  906 |     |      * @dev Returns the downcasted int104 from int256, reverting on
  907 |     |      * overflow (when the input is less than smallest int104 or
  908 |     |      * greater than largest int104).
  909 |     |      *
  910 |     |      * Counterpart to Solidity's `int104` operator.
  911 |     |      *
  912 |     |      * Requirements:
  913 |     |      *
  914 |     |      * - input must fit into 104 bits
  915 |     |      */
  916 |     |     function toInt104(int256 value) internal pure returns (int104 downcasted) {
  917 |     |         downcasted = int104(value);
  918 |     |         if (downcasted != value) {
  919 |     |             revert SafeCastOverflowedIntDowncast(104, value);
  920 |     |         }
  921 |     |     }
  922 |     | 
  923 |     |     /**
  924 |     |      * @dev Returns the downcasted int96 from int256, reverting on
  925 |     |      * overflow (when the input is less than smallest int96 or
  926 |     |      * greater than largest int96).
  927 |     |      *
  928 |     |      * Counterpart to Solidity's `int96` operator.
  929 |     |      *
  930 |     |      * Requirements:
  931 |     |      *
  932 |     |      * - input must fit into 96 bits
  933 |     |      */
  934 |     |     function toInt96(int256 value) internal pure returns (int96 downcasted) {
  935 |     |         downcasted = int96(value);
  936 |     |         if (downcasted != value) {
  937 |     |             revert SafeCastOverflowedIntDowncast(96, value);
  938 |     |         }
  939 |     |     }
  940 |     | 
  941 |     |     /**
  942 |     |      * @dev Returns the downcasted int88 from int256, reverting on
  943 |     |      * overflow (when the input is less than smallest int88 or
  944 |     |      * greater than largest int88).
  945 |     |      *
  946 |     |      * Counterpart to Solidity's `int88` operator.
  947 |     |      *
  948 |     |      * Requirements:
  949 |     |      *
  950 |     |      * - input must fit into 88 bits
  951 |     |      */
  952 |     |     function toInt88(int256 value) internal pure returns (int88 downcasted) {
  953 |     |         downcasted = int88(value);
  954 |     |         if (downcasted != value) {
  955 |     |             revert SafeCastOverflowedIntDowncast(88, value);
  956 |     |         }
  957 |     |     }
  958 |     | 
  959 |     |     /**
  960 |     |      * @dev Returns the downcasted int80 from int256, reverting on
  961 |     |      * overflow (when the input is less than smallest int80 or
  962 |     |      * greater than largest int80).
  963 |     |      *
  964 |     |      * Counterpart to Solidity's `int80` operator.
  965 |     |      *
  966 |     |      * Requirements:
  967 |     |      *
  968 |     |      * - input must fit into 80 bits
  969 |     |      */
  970 |     |     function toInt80(int256 value) internal pure returns (int80 downcasted) {
  971 |     |         downcasted = int80(value);
  972 |     |         if (downcasted != value) {
  973 |     |             revert SafeCastOverflowedIntDowncast(80, value);
  974 |     |         }
  975 |     |     }
  976 |     | 
  977 |     |     /**
  978 |     |      * @dev Returns the downcasted int72 from int256, reverting on
  979 |     |      * overflow (when the input is less than smallest int72 or
  980 |     |      * greater than largest int72).
  981 |     |      *
  982 |     |      * Counterpart to Solidity's `int72` operator.
  983 |     |      *
  984 |     |      * Requirements:
  985 |     |      *
  986 |     |      * - input must fit into 72 bits
  987 |     |      */
  988 |     |     function toInt72(int256 value) internal pure returns (int72 downcasted) {
  989 |     |         downcasted = int72(value);
  990 |     |         if (downcasted != value) {
  991 |     |             revert SafeCastOverflowedIntDowncast(72, value);
  992 |     |         }
  993 |     |     }
  994 |     | 
  995 |     |     /**
  996 |     |      * @dev Returns the downcasted int64 from int256, reverting on
  997 |     |      * overflow (when the input is less than smallest int64 or
  998 |     |      * greater than largest int64).
  999 |     |      *
 1000 |     |      * Counterpart to Solidity's `int64` operator.
 1001 |     |      *
 1002 |     |      * Requirements:
 1003 |     |      *
 1004 |     |      * - input must fit into 64 bits
 1005 |     |      */
 1006 |     |     function toInt64(int256 value) internal pure returns (int64 downcasted) {
 1007 |     |         downcasted = int64(value);
 1008 |     |         if (downcasted != value) {
 1009 |     |             revert SafeCastOverflowedIntDowncast(64, value);
 1010 |     |         }
 1011 |     |     }
 1012 |     | 
 1013 |     |     /**
 1014 |     |      * @dev Returns the downcasted int56 from int256, reverting on
 1015 |     |      * overflow (when the input is less than smallest int56 or
 1016 |     |      * greater than largest int56).
 1017 |     |      *
 1018 |     |      * Counterpart to Solidity's `int56` operator.
 1019 |     |      *
 1020 |     |      * Requirements:
 1021 |     |      *
 1022 |     |      * - input must fit into 56 bits
 1023 |     |      */
 1024 |     |     function toInt56(int256 value) internal pure returns (int56 downcasted) {
 1025 |     |         downcasted = int56(value);
 1026 |     |         if (downcasted != value) {
 1027 |     |             revert SafeCastOverflowedIntDowncast(56, value);
 1028 |     |         }
 1029 |     |     }
 1030 |     | 
 1031 |     |     /**
 1032 |     |      * @dev Returns the downcasted int48 from int256, reverting on
 1033 |     |      * overflow (when the input is less than smallest int48 or
 1034 |     |      * greater than largest int48).
 1035 |     |      *
 1036 |     |      * Counterpart to Solidity's `int48` operator.
 1037 |     |      *
 1038 |     |      * Requirements:
 1039 |     |      *
 1040 |     |      * - input must fit into 48 bits
 1041 |     |      */
 1042 |     |     function toInt48(int256 value) internal pure returns (int48 downcasted) {
 1043 |     |         downcasted = int48(value);
 1044 |     |         if (downcasted != value) {
 1045 |     |             revert SafeCastOverflowedIntDowncast(48, value);
 1046 |     |         }
 1047 |     |     }
 1048 |     | 
 1049 |     |     /**
 1050 |     |      * @dev Returns the downcasted int40 from int256, reverting on
 1051 |     |      * overflow (when the input is less than smallest int40 or
 1052 |     |      * greater than largest int40).
 1053 |     |      *
 1054 |     |      * Counterpart to Solidity's `int40` operator.
 1055 |     |      *
 1056 |     |      * Requirements:
 1057 |     |      *
 1058 |     |      * - input must fit into 40 bits
 1059 |     |      */
 1060 |     |     function toInt40(int256 value) internal pure returns (int40 downcasted) {
 1061 |     |         downcasted = int40(value);
 1062 |     |         if (downcasted != value) {
 1063 |     |             revert SafeCastOverflowedIntDowncast(40, value);
 1064 |     |         }
 1065 |     |     }
 1066 |     | 
 1067 |     |     /**
 1068 |     |      * @dev Returns the downcasted int32 from int256, reverting on
 1069 |     |      * overflow (when the input is less than smallest int32 or
 1070 |     |      * greater than largest int32).
 1071 |     |      *
 1072 |     |      * Counterpart to Solidity's `int32` operator.
 1073 |     |      *
 1074 |     |      * Requirements:
 1075 |     |      *
 1076 |     |      * - input must fit into 32 bits
 1077 |     |      */
 1078 |     |     function toInt32(int256 value) internal pure returns (int32 downcasted) {
 1079 |     |         downcasted = int32(value);
 1080 |     |         if (downcasted != value) {
 1081 |     |             revert SafeCastOverflowedIntDowncast(32, value);
 1082 |     |         }
 1083 |     |     }
 1084 |     | 
 1085 |     |     /**
 1086 |     |      * @dev Returns the downcasted int24 from int256, reverting on
 1087 |     |      * overflow (when the input is less than smallest int24 or
 1088 |     |      * greater than largest int24).
 1089 |     |      *
 1090 |     |      * Counterpart to Solidity's `int24` operator.
 1091 |     |      *
 1092 |     |      * Requirements:
 1093 |     |      *
 1094 |     |      * - input must fit into 24 bits
 1095 |     |      */
 1096 |     |     function toInt24(int256 value) internal pure returns (int24 downcasted) {
 1097 |     |         downcasted = int24(value);
 1098 |     |         if (downcasted != value) {
 1099 |     |             revert SafeCastOverflowedIntDowncast(24, value);
 1100 |     |         }
 1101 |     |     }
 1102 |     | 
 1103 |     |     /**
 1104 |     |      * @dev Returns the downcasted int16 from int256, reverting on
 1105 |     |      * overflow (when the input is less than smallest int16 or
 1106 |     |      * greater than largest int16).
 1107 |     |      *
 1108 |     |      * Counterpart to Solidity's `int16` operator.
 1109 |     |      *
 1110 |     |      * Requirements:
 1111 |     |      *
 1112 |     |      * - input must fit into 16 bits
 1113 |     |      */
 1114 |     |     function toInt16(int256 value) internal pure returns (int16 downcasted) {
 1115 |     |         downcasted = int16(value);
 1116 |     |         if (downcasted != value) {
 1117 |     |             revert SafeCastOverflowedIntDowncast(16, value);
 1118 |     |         }
 1119 |     |     }
 1120 |     | 
 1121 |     |     /**
 1122 |     |      * @dev Returns the downcasted int8 from int256, reverting on
 1123 |     |      * overflow (when the input is less than smallest int8 or
 1124 |     |      * greater than largest int8).
 1125 |     |      *
 1126 |     |      * Counterpart to Solidity's `int8` operator.
 1127 |     |      *
 1128 |     |      * Requirements:
 1129 |     |      *
 1130 |     |      * - input must fit into 8 bits
 1131 |     |      */
 1132 |     |     function toInt8(int256 value) internal pure returns (int8 downcasted) {
 1133 |     |         downcasted = int8(value);
 1134 |     |         if (downcasted != value) {
 1135 |     |             revert SafeCastOverflowedIntDowncast(8, value);
 1136 |     |         }
 1137 |     |     }
 1138 |     | 
 1139 |     |     /**
 1140 |     |      * @dev Converts an unsigned uint256 into a signed int256.
 1141 |     |      *
 1142 |     |      * Requirements:
 1143 |     |      *
 1144 |     |      * - input must be less than or equal to maxInt256.
 1145 |     |      */
 1146 |     |     function toInt256(uint256 value) internal pure returns (int256) {
 1147 |     |         // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive
 1148 |     |         if (value > uint256(type(int256).max)) {
 1149 |     |             revert SafeCastOverflowedUintToInt(value);
 1150 |     |         }
 1151 |     |         return int256(value);
 1152 |     |     }
 1153 |     | }
 1154 |     | 

/code/test/echidna/Echidna_ControllerHubProps.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.24;
  3 |     | 
  4 |     | import {ControllerHub} from "contracts/hub/ControllerHub.sol";
  5 |     | import {PriceOracleRouter} from "contracts/hub/PriceOracleRouter.sol";
  6 |     | import {MockAggregator} from "contracts/mocks/MockAggregator.sol";
  7 |     | 
  8 |     | // Minimal ERC20 stub compatible with ControllerHub expectations
  9 | *   | contract ERC20Mini {
 10 |     |     mapping(address => uint256) public balanceOf;
 11 |     |     function decimals() external pure returns (uint8) { return 18; }
 12 |     |     function mint(address to, uint256 a) external { balanceOf[to] += a; }
 13 |     | }
 14 |     | 
 15 |     | // Echidna property harness for ControllerHub
 16 |     | // - Uses simple wrappers so Echidna can fuzz borrow/repay and pause toggles
 17 |     | // - Ensures total borrows never exceed the configured borrowCap
 18 |     | // - Ensures pause flag prevents borrow growth
 19 | *r  | contract Echidna_ControllerHubProps {
 20 |     |     ControllerHub public hub;
 21 |     |     PriceOracleRouter public router;
 22 | *   |     ERC20Mini public asset;
 23 | *   |     ERC20Mini public lst;
 24 |     |     MockAggregator public aggAsset;
 25 | *   |     MockAggregator public aggLst;
 26 |     | 
 27 |     |     constructor() {
 28 |     |         // governor is this harness contract so Echidna can call governor-only methods through wrappers
 29 | *   |         router = new PriceOracleRouter();
 30 | *   |         router.initialize(address(this));
 31 | *   |         hub = new ControllerHub();
 32 | *   |         hub.initialize(address(this), address(router));
 33 |     | 
 34 |     |         // set up assets and price feeds
 35 | *   |         asset = new ERC20Mini();
 36 | *   |         lst = new ERC20Mini();
 37 | *   |         aggAsset = new MockAggregator(1e8, block.timestamp);
 38 | *   |         aggLst = new MockAggregator(1e8, block.timestamp);
 39 | *   |         router.setFeed(address(asset), address(aggAsset), address(0), 8, 1 days, 0);
 40 | *   |         router.setFeed(address(lst), address(aggLst), address(0), 8, 1 days, 0);
 41 |     | 
 42 |     |         // list a market with sane parameters
 43 | *   |         ControllerHub.MarketParams memory p = ControllerHub.MarketParams({
 44 | *   |             ltvBps: 5000,
 45 | *   |             liqThresholdBps: 6000,
 46 | *   |             reserveFactorBps: 1000,
 47 | *   |             borrowCap: 1_000_000 ether,
 48 | *   |             kinkBps: 8000,
 49 | *   |             slope1Ray: 1e16,
 50 | *   |             slope2Ray: 2e16,
 51 |     |             baseRateRay: 0,
 52 |     |             lst: address(lst),
 53 |     |             vault: address(this)
 54 |     |         });
 55 | *   |         hub.listMarket(address(asset), abi.encode(p));
 56 |     | 
 57 |     |         // enter market with some collateral
 58 | *   |         lst.mint(address(this), 1_000_000 ether);
 59 | *   |         hub.enterMarket(address(lst));
 60 |     |     }
 61 |     | 
 62 |     |     // Fuzz entrypoints (Echidna will generate sequences of these calls)
 63 |     |     function borrow(uint256 amt) public {
 64 | *   |         uint256 a = amt % (10_000 ether);
 65 |     |         // swallow reverts to allow Echidna to explore invalid inputs too
 66 | *   |         try hub.borrow(address(asset), a, 0) { } catch { }
 67 |     |     }
 68 |     | 
 69 |     |     function repay(uint256 amt) public {
 70 | *   |         uint256 a = amt % (10_000 ether);
 71 | *   |         try hub.repay(address(asset), a, 0) { } catch { }
 72 |     |     }
 73 |     | 
 74 |     |     function setPause(bool pauseBorrow, bool pauseLiq) public {
 75 |     |         // governor-only; ok since governor is this harness contract
 76 | *   |         hub.setPause(pauseBorrow, pauseLiq);
 77 |     |     }
 78 |     | 
 79 |     |     // Properties
 80 |     |     function echidna_total_borrows_never_exceed_cap() public returns (bool) {
 81 |     |         (ControllerHub.MarketState memory s, ControllerHub.MarketParams memory p, ) = hub.marketStateExtended(address(asset));
 82 |     |         return s.totalBorrows <= p.borrowCap;
 83 |     |     }
 84 |     | 
 85 |     |     function echidna_pause_blocks_borrow_growth() public returns (bool) {
 86 |     |         // snapshot borrows, enable borrow pause, try to borrow, ensure not increased
 87 |     |         (ControllerHub.MarketState memory sBefore, , ) = hub.marketStateExtended(address(asset));
 88 |     |         hub.setPause(true, false);
 89 |     |         // attempt to increase borrows
 90 |     |         try hub.borrow(address(asset), 1 ether, 0) { } catch { }
 91 |     |         (ControllerHub.MarketState memory sAfter, , ) = hub.marketStateExtended(address(asset));
 92 |     |         // best-effort: unpause to not poison further sequences
 93 |     |         hub.setPause(false, false);
 94 |     |         return sAfter.totalBorrows <= sBefore.totalBorrows;
 95 |     |     }
 96 |     | }
 97 |     | 

